<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>Vue1.0+Webpack1+Gulp项目升级构建方案的踩坑路 | GeekHouse</title>
<meta name=keywords content="Engineering">
<meta name=description content="最近半年在维护公司的一个管理后台项目，搭建之初的技术栈比较混乱，构建方案采用了Gulp中调用Webpack的方式，Gulp负责处理.html文件，Webpack负责加载.vue、.js等。而在这一套构建方案中，主要有这些问题：
 没有实现JS压缩、CSS兼容等功能。 在开发模式下，保存代码，项目会进行完全的重新打包，持续构建速度不仅缓慢，还会产生缓存的现象（构建完成后刷新页面改动不生效）。 由于目前的方案没有使用http-proxy-middleware这样的请求代理模块，导致项目在本地开发时还要部署后端服务，对新接手的开发者不友好，而且经常由于沟通不及时产生测试环境与本地环境的代码同步问题。  因此，在熟悉这个项目之后，打算对其构建方案进行升级，主要为了解决上述的问题。
1. 原有构建方案描述 原有构建速度  npm run build：打包约50s npm run dev：开启开发模式约50s，保存自动重新编译需约6s，编译完成后需要刷新才能看到效果，偶尔因缓存问题需要再次自动重新编译才能看到效果  原有构建结果  ./build/development：存放渲染后的js文件 ./build/html：存放渲染后的html文件 ./build/rev：保存各个入口文件hash值的json文件  打包代码解析 /** * 使用gulp-clean插件删除build目录下的文件 */ gulp.task('clean', function () { if (!stopClean) { return gulp.src('build/' + directory, { read: false }).pipe(clean()) } }) /** * 使用webpack打包vue与js文件，在clean之后进行 */ gulp.task('webpack', ['clean'], function (callback) { deCompiler.run(function (err, stats) { if (err) throw new gutil.PluginError('webpack', err) gutil.log('[webpack]', stats.toString({})) callback() }) }) /** * 使用gulp-uglify插件对js文件进行丑化，在webpack之后进行 */ gulp.">
<meta name=author content="YYJ">
<link rel=canonical href=https://geekhouse.top/posts/engineering_vue1_update/>
<meta name=google-site-verification content="XYZabc">
<meta name=yandex-verification content="XYZabc">
<meta name=msvalidate.01 content="XYZabc">
<link crossorigin=anonymous href=/assets/css/stylesheet.min.83c4eb6d61e6a4176992e4a4ce8786fc30bd40032ba8663ec5d11e285a965766.css integrity="sha256-g8TrbWHmpBdpkuSkzoeG/DC9QAMrqGY+xdEeKFqWV2Y=" rel="preload stylesheet" as=style>
<link rel=icon href=https://geekhouse.top/%3Clink%20/%20abs%20url%3E>
<link rel=icon type=image/png sizes=16x16 href=https://geekhouse.top/%3Clink%20/%20abs%20url%3E>
<link rel=icon type=image/png sizes=32x32 href=https://geekhouse.top/%3Clink%20/%20abs%20url%3E>
<link rel=apple-touch-icon href=https://geekhouse.top/%3Clink%20/%20abs%20url%3E>
<link rel=mask-icon href=https://geekhouse.top/%3Clink%20/%20abs%20url%3E>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<meta name=generator content="Hugo 0.88.1">
<noscript>
<style>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-184187677-2','auto'),ga('send','pageview'))</script><meta property="og:title" content="Vue1.0+Webpack1+Gulp项目升级构建方案的踩坑路">
<meta property="og:description" content="最近半年在维护公司的一个管理后台项目，搭建之初的技术栈比较混乱，构建方案采用了Gulp中调用Webpack的方式，Gulp负责处理.html文件，Webpack负责加载.vue、.js等。而在这一套构建方案中，主要有这些问题：
 没有实现JS压缩、CSS兼容等功能。 在开发模式下，保存代码，项目会进行完全的重新打包，持续构建速度不仅缓慢，还会产生缓存的现象（构建完成后刷新页面改动不生效）。 由于目前的方案没有使用http-proxy-middleware这样的请求代理模块，导致项目在本地开发时还要部署后端服务，对新接手的开发者不友好，而且经常由于沟通不及时产生测试环境与本地环境的代码同步问题。  因此，在熟悉这个项目之后，打算对其构建方案进行升级，主要为了解决上述的问题。
1. 原有构建方案描述 原有构建速度  npm run build：打包约50s npm run dev：开启开发模式约50s，保存自动重新编译需约6s，编译完成后需要刷新才能看到效果，偶尔因缓存问题需要再次自动重新编译才能看到效果  原有构建结果  ./build/development：存放渲染后的js文件 ./build/html：存放渲染后的html文件 ./build/rev：保存各个入口文件hash值的json文件  打包代码解析 /** * 使用gulp-clean插件删除build目录下的文件 */ gulp.task('clean', function () { if (!stopClean) { return gulp.src('build/' + directory, { read: false }).pipe(clean()) } }) /** * 使用webpack打包vue与js文件，在clean之后进行 */ gulp.task('webpack', ['clean'], function (callback) { deCompiler.run(function (err, stats) { if (err) throw new gutil.PluginError('webpack', err) gutil.log('[webpack]', stats.toString({})) callback() }) }) /** * 使用gulp-uglify插件对js文件进行丑化，在webpack之后进行 */ gulp.">
<meta property="og:type" content="article">
<meta property="og:url" content="https://geekhouse.top/posts/engineering_vue1_update/"><meta property="og:image" content="https://geekhouse.top/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2019-04-04T00:00:00+00:00">
<meta property="article:modified_time" content="2019-04-04T00:00:00+00:00"><meta property="og:site_name" content="ExampleSite">
<meta name=twitter:card content="summary_large_image">
<meta name=twitter:image content="https://geekhouse.top/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E">
<meta name=twitter:title content="Vue1.0+Webpack1+Gulp项目升级构建方案的踩坑路">
<meta name=twitter:description content="最近半年在维护公司的一个管理后台项目，搭建之初的技术栈比较混乱，构建方案采用了Gulp中调用Webpack的方式，Gulp负责处理.html文件，Webpack负责加载.vue、.js等。而在这一套构建方案中，主要有这些问题：
 没有实现JS压缩、CSS兼容等功能。 在开发模式下，保存代码，项目会进行完全的重新打包，持续构建速度不仅缓慢，还会产生缓存的现象（构建完成后刷新页面改动不生效）。 由于目前的方案没有使用http-proxy-middleware这样的请求代理模块，导致项目在本地开发时还要部署后端服务，对新接手的开发者不友好，而且经常由于沟通不及时产生测试环境与本地环境的代码同步问题。  因此，在熟悉这个项目之后，打算对其构建方案进行升级，主要为了解决上述的问题。
1. 原有构建方案描述 原有构建速度  npm run build：打包约50s npm run dev：开启开发模式约50s，保存自动重新编译需约6s，编译完成后需要刷新才能看到效果，偶尔因缓存问题需要再次自动重新编译才能看到效果  原有构建结果  ./build/development：存放渲染后的js文件 ./build/html：存放渲染后的html文件 ./build/rev：保存各个入口文件hash值的json文件  打包代码解析 /** * 使用gulp-clean插件删除build目录下的文件 */ gulp.task('clean', function () { if (!stopClean) { return gulp.src('build/' + directory, { read: false }).pipe(clean()) } }) /** * 使用webpack打包vue与js文件，在clean之后进行 */ gulp.task('webpack', ['clean'], function (callback) { deCompiler.run(function (err, stats) { if (err) throw new gutil.PluginError('webpack', err) gutil.log('[webpack]', stats.toString({})) callback() }) }) /** * 使用gulp-uglify插件对js文件进行丑化，在webpack之后进行 */ gulp.">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://geekhouse.top/posts/"},{"@type":"ListItem","position":2,"name":"Vue1.0+Webpack1+Gulp项目升级构建方案的踩坑路","item":"https://geekhouse.top/posts/engineering_vue1_update/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Vue1.0+Webpack1+Gulp项目升级构建方案的踩坑路","name":"Vue1.0\u002bWebpack1\u002bGulp项目升级构建方案的踩坑路","description":"最近半年在维护公司的一个管理后台项目，搭建之初的技术栈比较混乱，构建方案采用了Gulp中调用Webpack的方式，Gulp负责处理.html文件，Webpack负责加载.vue、.js等。而在这一套构建方案中，主要有这些问题：\n 没有实现JS压缩、CSS兼容等功能。 在开发模式下，保存代码，项目会进行完全的重新打包，持续构建速度不仅缓慢，还会产生缓存的现象（构建完成后刷新页面改动不生效）。 由于目前的方案没有使用http-proxy-middleware这样的请求代理模块，导致项目在本地开发时还要部署后端服务，对新接手的开发者不友好，而且经常由于沟通不及时产生测试环境与本地环境的代码同步问题。  因此，在熟悉这个项目之后，打算对其构建方案进行升级，主要为了解决上述的问题。\n1. 原有构建方案描述 原有构建速度  npm run build：打包约50s npm run dev：开启开发模式约50s，保存自动重新编译需约6s，编译完成后需要刷新才能看到效果，偶尔因缓存问题需要再次自动重新编译才能看到效果  原有构建结果  ./build/development：存放渲染后的js文件 ./build/html：存放渲染后的html文件 ./build/rev：保存各个入口文件hash值的json文件  打包代码解析 /** * 使用gulp-clean插件删除build目录下的文件 */ gulp.task(\u0026#39;clean\u0026#39;, function () { if (!stopClean) { return gulp.src(\u0026#39;build/\u0026#39; + directory, { read: false }).pipe(clean()) } }) /** * 使用webpack打包vue与js文件，在clean之后进行 */ gulp.task(\u0026#39;webpack\u0026#39;, [\u0026#39;clean\u0026#39;], function (callback) { deCompiler.run(function (err, stats) { if (err) throw new gutil.PluginError(\u0026#39;webpack\u0026#39;, err) gutil.log(\u0026#39;[webpack]\u0026#39;, stats.toString({})) callback() }) }) /** * 使用gulp-uglify插件对js文件进行丑化，在webpack之后进行 */ gulp.","keywords":["Engineering"],"articleBody":"最近半年在维护公司的一个管理后台项目，搭建之初的技术栈比较混乱，构建方案采用了Gulp中调用Webpack的方式，Gulp负责处理.html文件，Webpack负责加载.vue、.js等。而在这一套构建方案中，主要有这些问题：\n 没有实现JS压缩、CSS兼容等功能。 在开发模式下，保存代码，项目会进行完全的重新打包，持续构建速度不仅缓慢，还会产生缓存的现象（构建完成后刷新页面改动不生效）。 由于目前的方案没有使用http-proxy-middleware这样的请求代理模块，导致项目在本地开发时还要部署后端服务，对新接手的开发者不友好，而且经常由于沟通不及时产生测试环境与本地环境的代码同步问题。  因此，在熟悉这个项目之后，打算对其构建方案进行升级，主要为了解决上述的问题。\n1. 原有构建方案描述 原有构建速度  npm run build：打包约50s npm run dev：开启开发模式约50s，保存自动重新编译需约6s，编译完成后需要刷新才能看到效果，偶尔因缓存问题需要再次自动重新编译才能看到效果  原有构建结果  ./build/development：存放渲染后的js文件 ./build/html：存放渲染后的html文件 ./build/rev：保存各个入口文件hash值的json文件  打包代码解析 /** * 使用gulp-clean插件删除build目录下的文件 */ gulp.task('clean', function () { if (!stopClean) { return gulp.src('build/' + directory, { read: false }).pipe(clean()) } }) /** * 使用webpack打包vue与js文件，在clean之后进行 */ gulp.task('webpack', ['clean'], function (callback) { deCompiler.run(function (err, stats) { if (err) throw new gutil.PluginError('webpack', err) gutil.log('[webpack]', stats.toString({})) callback() }) }) /** * 使用gulp-uglify插件对js文件进行丑化，在webpack之后进行 */ gulp.task('minify', ['webpack'], function () { if (environment) { return } else { return gulp.src('build/' + directory + '/*.js').pipe(uglify()) } }) /** * 使用gulp-rev插件为打包后的文件增加hash，在minify之后运行 * * gulp-rev会做什么： * 根据静态资源内容，生成md5签名，打包出来的文件名会加上md5签名，同时生成一个json用来保存文件名路径对应关系。 * 替换html里静态资源的路径为带有md5值的文件路径，这样html才能找到资源路径。 * 有些人可能会做：静态服务器配置静态资源的过期时间为永不过期。 * 达到什么效果： * 静态资源只需请求一次，永久缓存，不会发送协商请求304 * 版本更新只会更新修改的静态资源内容 * 不删除旧版本的静态资源，版本回滚的时候只需要更新html，同样不会增加http请求次数 */ gulp.task('hashJS', ['minify'], function () { var dest = gulp.src(['一串入口文件...']) .pipe(rev()) // 设置文件的hash key  .pipe(gulp.dest('build/' + directory)) // 将经过管道处理的文件写出到目录  .pipe(rev.manifest({})) // 生成映射hash key的json  .pipe(gulp.dest('build/rev')) // 将经过管道处理的文件写出到目录  !environment \u0026\u0026 gulp.src(['一串入口文件...']).pipe(clean()) return dest }) /** * 使用gulp-rev-replace插件为html中引用的js和css替换新的hash * 使用gulp-livereload插件在所有文件重新打包完成后局部更新页面 */ gulp.task('revReplace', ['hashJS'], function () { return gulp.src(['html/*.html']) .pipe(revReplace({ ... })) // 给html中的js引用提供新的hash  .pipe(gulp.dest('build/html')) // 输出文件  .pipe(livereload()) // 局部更新页面 }) /** * 使用gulp.watch，当应用程序目录下有任何文件发生改变，则重新执行一遍打包命令 * gulp.watch：监视文件，并且可以在文件发生改动时候做一些事情。 */ gulp.task('watch', ['revReplace'], function () { stopClean = true livereload.listen() gulp.watch('app/**/*', ['clean', 'webpack', 'minify', 'hashJS', 'revReplace']) }) /** * 输出dev和build的工作流 */ gulp.task('default', ['clean', 'webpack', 'minify', 'hashJS', 'revReplace', 'watch']) // dev gulp.task('build', ['clean', 'webpack', 'minify', 'hashJS', 'revReplace']) // build /** * webpack配置 */ var devCompiler = webpack({ entry: { ... // 一众入口文件  vendor: ['vue', 'vue-router', 'lodash', 'echarts'] // 公共模块  }, output: { path: ..., // 所有输出文件的目标路径  publicPath: ..., // 输出解析文件的目录  filename: ..., // 输出文件  chunkFilename: ... // 通过异步请求的文件  }, // 排除以下内容打包到 bundle，减小文件大小  external: { jquery: 'jQuery', dialog: 'dialog' }, plugins: [ /** * 通过将公共模块拆出来，最终合成的文件能够在最开始的时候加载一次，便存到缓存中供后续使用。 * 这个带来页面速度上的提升，因为浏览器会迅速将公共的代码从缓存中取出来，而不是每次访问一个新页面时，再去加载一个更大的文件。 */ new webpack.optimize.CommonsChunkPlugin({ name: ['vendor'] }), /** * DefinePlugin 允许创建一个在编译时可以配置的全局常量。这可能会对开发模式和生产模式的构建允许不同的行为非常有用。 */ new webpack.DefinePlugin({ __VERSION__: new Date().getTime() }) ], resolve: { root: __dirname, extensions: ['', '.js', '.vue', '.json'], // 解析组件的文件后缀白名单  alias: { ... } // 配置路径别名  }, module: { // 各个文件的loaders  loaders: [ { test: /\\.vue$/, loader: 'vue-loader' }, { test: /\\.css$/, loader: 'style-loader!css-loader' }, { test: /\\.jsx$/, loader: 'babel-loader', include: [path.join(__dirname, 'app')], exclude: /core/ }, { test: /\\.json$/, loader: 'json' } ] }, vue: { loaders: { js: 'babel-loader' } } }) 2. 将Gulp的功能移到Webpack1上执行 使用html-webpack-plugin插件构建项目的主.html文件 module.exports = { plugins: [ new HtmlWebpackPlugin({ filename: '...', // 输出的路径  template: '...', // 提取源html的路径  chunks: ['...'], // 需要导入的模块  inject: true // 是否附加到body底部  }) ] } 使用webpack.optimize.UglifyJsPlugin插件进行JS压缩 module.exports = { plugins: [ new webpack.optimize.UglifyJsPlugin({ compress: { warnings: false } }) ] } 使用webpack-dev-server模块，提供node搭建的开发环境 module.exports = { devServer: { clientLogLevel: 'warning', // 输出日志的级别，配置为警告级别以上才输出  inline: true, // 启动 live reload  hot: true, // 允许启用热重载  compress: true, // 对所有静态资源进行gzip压缩  open: true, // 默认在启动本地服务时打开浏览器  quiet: true, // 禁止输出繁杂的构建日志  host: ..., // 服务启动的域名  port: ..., // 服务启动的端口  proxy: { ... }, // http代理配置  /** * 这个配置常用于解决spa应用h5路由模式下将所有404路由匹配回index.html的问题 * 由于生产环境为主页匹配了一个比较简单的别名，因此开发环境也照搬后端服务的配置 */ historyApiFallback: { rewrites: [{ from: '/^\\/admin/', to: '...' }] } } } 踩坑  webpack-dev-server@3.2.1 requires a peer of webpack^@4.0.0 but none is installed.：这两个模块版本不兼容，回退到webpack-dev-server@2成功运行。 Cannot resolve module 'fsevents' ...：将全局的webpack调用改为直接从node_modules/webpack下直接调用，解决了问题，node node_modules/webpack/bin/webpack.js --config webpack.config.js。 Cannot resolve module 'fs' ...：配置config.node.fs = 'empty'，为Webpack提供node原生模块，使其能加载到这个对象。 热重载只对.js和.css及.vue中的内样式生效，对.vue文件中的html模板及js内容都不生效，会打印“模块代码已发生改变并重新编译，但热重载不生效，可能会启用全局刷新的策略”之类的信息，暂时没有解决，初步判断是低版本的vue-hot-reload-api对这些部分的处理有问题，有大神了解原理可以在评论区科普一哈=.=。  3. 从Webpack1升级到Webpack3 由于Webpack2与Webpack3几乎完全兼容，只是涉及到一些增量的功能，因此选择直接从Webpack1迁移到Webapck3，先在项目中安装Webpack3，然后根据Webpack2文档中《从Webpack1迁移》的章节，对配置项进行更改，参考的文档戳这个：https://www.html.cn/doc/webpack2/guides/migrating/\n这次升级没有遇到什么问题，根据文档配置稍作更改就跑通了。梳理一下目前为止实现的功能：\n 新的Webpack构建代码已经实现了原有的所有功能，下面列举新增的功能。 使用webpack-dev-server作为开发服务器，实现了保存时live reload的功能。 使用http-proxy-middleware插件，将请求直接代理到测试服，让开发环境脱离了本地部署的后端服务，大大降低了开发环境部署的时间成本。 新增friendly-errors-webpack-plugin，输出友好的构建日志，打印几个重要模块的开发环境地址，配置方面完全参考了vue-cli@2的默认配置。 新增postcss-loader，对css添加兼容处理，配置方面完全参考了vue-cli@2的默认配置。 使用webpack.optimize.UglifyJsPlugin压缩js代码。  尝试进行构建，输出构建时间记录：\n npm run build：约135s npm run dev：初次构建约58s，持续构建约30s  项目构建时间过长（第一次打包把自己吓了一跳…），只能继续寻求构建速度上的优化\n4. 在Webpack3下进行构建速度的优化 使用webpack-jarvis监测构建性能 webpack-jarvis是一个图形化的webpack性能监测工具，它配置简便，对构建过程的时间占比、构建结果的详细记录都有具体的输出\n// 经过简单的配置就可以在本地3001端口输出构建结果记录 const Jarvis = require('webpack-jarvis') module.exports = { plugins: [ new Jarvis({ watchOnly: false, port: 3001 }) ] } 使用happypack 先根据网上搜到的文章，做一些简单的优化，如使用happypack，这个模块通过多进程模型，来加速代码构建，但是使用之后貌似没有太明显的结果，构建时间大概减少了几秒吧…暂时还不太懂这个模块对优化什么场景的效果比较明显，之前有看到一篇讲解happypack原理的文章，但还没细看，有兴趣小伙伴可以研究一下，要是能在评论里简洁明了的给渣渣楼主解释一下就更好了TUT：http://taobaofed.org/blog/2016/12/08/happypack-source-code-analysis/\nconst HappyPack = require('happypack') const os = require('os') const happyThreadPool = HappyPack.ThreadPool({ size: os.cpus().length }) module.exports = { plugins: [ new HappyPack({ // happypack的id，在调用时需要声明，若需要编译其他类型的文件需要再声明一个happypack  id: 'js', // cacheDirectory：设置后，将尽量在babel编译时使用缓存加载器的结果，避免重新走一遍babel的高昂代价  use: [{ loader: 'babel-loader', cacheDirectory: true }], // 根据cpu的核心数判断需要拆分多少个进程池  threadPool: happyThreadPool, // 是否输出编译过程的日志  verbose: true }) ] } 做完这一步后，输出构建时间记录：\n npm run build：约130s npm run dev：初次构建约60s，持续构建约30s  devtool配置为cheap-module-eval-source-map devtool选项启用cheap-module-eval-source-map模式：vue-cli@2默认配置为这种模式，cheap代表在输出source-map时省略列信息；module表示在编译过程中启用如babel-loader这样的预编译器，使得调试时可以直接看到未经编译的源代码；eval表示启用eval模式编译，该模式直接使用eval函数执行编译后模块的字符串，减少了将字符串转化为可执行的代码文件这个步骤，加快了项目开发中重建的速度；source-map表示输出源代码的映射表，使得开发时可以直接把错误定位到源代码，提高开发效率。\n做完这一步后，效果并不明显=.=（相比原来的source-map），大概减少了几秒，输出构建时间记录：\n npm run build：约130s npm run dev：初次构建约58s，持续构建约30s  使用html-webpack-plugin-for-multihtml提升多入口项目重建速度 重建一次竟然需要30s！各种搜索找到了html-webpack-plugin的一条issue，发现html-webpack-plugin@2在构建多入口应用时速度确实有明显变慢的情况，原因是没有成功的对构建内容进行缓存，使每次重建都重新编译所有代码。作者给出的解决方案是使用这个模块的一个分支项目（是由作者本人fork原项目并针对这个问题进行修复的项目）html-webpack-plugin-for-multihtml，用法与html-webpack-plugin完全相同，使用之后重建仅需1s左右。\n做完这一步后，输出构建时间记录：\n npm run build：约130s npm run dev：初次构建约58s，持续构建约1s  使用webpack.DllPlugin提取公共模块 在输出结果中找到了不少较大的依赖包，如Vue的核心库、lodash、echarts等等，还有一些不希望被打包的静态资源，想办法避免每次都编译这些内容，提升编译速度，所以找到了这个插件。\nwebpack.DllPlugin这个插件是来源于Windows系统的.dll文件（动态链接库）的用法：首先通过DllPlugin模块构建出一个包含公共模块的包和一个映射表，再通过DllReferencePlugin模块通过映射表给每个模块关联对应的依赖，这样可以对这些公共模块进行预先打包，以后构建的时候就不需要处理这些模块，减少打包时间。\n// webpack.dll.conf.js const webpack = require('webpack') module.exports = { entry: { vendor: [...] }, output: { path: resolve('build/development'), filename: '[name].dll.js', library: '[name]_library' }, plugins: [ new webpack.optimize.UglifyJsPlugin(), new webpack.DllPlugin({ path: resolve('build/development/[name]-manifest.json'), // 生成manifest文件输出的位置和文件名称  name: '[name]-library', // 与output.library是一样的，对应manifest.json文件中name字段的值，防止全局变量冲突  context: __dirname }) ] } // webpack.base.conf.js const webpack = require('webpack') module.exports = { plugins: [ new webpack.DllReferencePlugin({ context: __dirname, manifest: require('../build/development/vendor-manifest.json') // 让webpack从映射表获取使用的依赖  }) ] } 打包出来之后还需要在html文件中引入公共库vendor.dll.js文件\nhtml headhead body div id=\"app\"div script src=\"/build/development/vendor.dll.js\"script  body html 做完这一步后，输出构建时间记录，发现构建效率有了明显的提高：\n npm run dll：约25s npm run build：约70s npm run dev：初次构建约55s，持续构建约1s  5. 后记 优化到这里就差不多结束，这次的优化为旧项目提供了新一代spa项目应有的一些功能，搭建了更现代的本地开发环境。由于本文篇幅有点太长，完整的配置就丢在另一篇文章里。\n6. Q\u0026A Q: 为什么不直接升级到Webpack4？\nA: Webpack4只支持vue-loader@15以上版本，而这个版本已经无法解析Vue1的文件。\n","wordCount":"698","inLanguage":"en","datePublished":"2019-04-04T00:00:00Z","dateModified":"2019-04-04T00:00:00Z","author":{"@type":"Person","name":"YYJ"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://geekhouse.top/posts/engineering_vue1_update/"},"publisher":{"@type":"Organization","name":"GeekHouse","logo":{"@type":"ImageObject","url":"https://geekhouse.top/%3Clink%20/%20abs%20url%3E"}}}</script>
</head>
<body id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=https://geekhouse.top/ accesskey=h title="GeekHouse (Alt + H)">GeekHouse</a>
<span class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</span>
</div>
<ul id=menu>
<li>
<a href=https://geekhouse.top/tags/ title=Tags>
<span>Tags</span>
</a>
</li>
<li>
<a href=https://geekhouse.top/timeline/ title=Timeline>
<span>Timeline</span>
</a>
</li>
<li>
<a href=https://geekhouse.top/about/ title=About>
<span>About</span>
</a>
</li>
<li>
<a href=https://geekhouse.top/search/ title="Search (Alt + /)" accesskey=/>
<span>Search</span>
</a>
</li>
</ul>
</nav>
</header>
<main class=main>
<script type=text/javascript async src="https://cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML">MathJax.Hub.Config({tex2jax:{inlineMath:[['$','$']],displayMath:[['$$','$$']],processEscapes:!0,processEnvironments:!0,skipTags:['script','noscript','style','textarea','pre'],TeX:{equationNumbers:{autoNumber:"AMS"},extensions:["AMSmath.js","AMSsymbols.js"]}}}),MathJax.Hub.Queue(function(){var b=MathJax.Hub.getAllJax(),a;for(a=0;a<b.length;a+=1)b[a].SourceElement().parentNode.className+=' has-jax'})</script>
<style>code.has-jax{font:inherit;font-size:100%;background:inherit;border:inherit;color:#515151}</style>
<article class=post-single>
<header class=post-header>
<h1 class=post-title>
Vue1.0+Webpack1+Gulp项目升级构建方案的踩坑路
</h1>
<div class=post-meta>April 4, 2019&nbsp;·&nbsp;4 min&nbsp;·&nbsp;YYJ&nbsp;|&nbsp;<a href=https://github.com/yyj08070631.github.io/content/posts/engineering_vue1_update/index.md rel="noopener noreferrer" target=_blank>Suggest Changes</a>
</div>
</header>
<div class=post-content><p>最近半年在维护公司的一个管理后台项目，搭建之初的技术栈比较混乱，构建方案采用了<code>Gulp</code>中调用<code>Webpack</code>的方式，<code>Gulp</code>负责处理<code>.html</code>文件，<code>Webpack</code>负责加载<code>.vue</code>、<code>.js</code>等。而在这一套构建方案中，主要有这些问题：</p>
<ol>
<li>没有实现JS压缩、CSS兼容等功能。</li>
<li>在开发模式下，保存代码，项目会进行完全的重新打包，持续构建速度不仅缓慢，还会产生缓存的现象（构建完成后刷新页面改动不生效）。</li>
<li>由于目前的方案没有使用<code>http-proxy-middleware</code>这样的请求代理模块，导致项目在本地开发时还要部署后端服务，对新接手的开发者不友好，而且经常由于沟通不及时产生测试环境与本地环境的代码同步问题。</li>
</ol>
<p>因此，在熟悉这个项目之后，打算对其构建方案进行升级，主要为了解决上述的问题。</p>
<h2 id=1-原有构建方案描述>1. 原有构建方案描述<a hidden class=anchor aria-hidden=true href=#1-原有构建方案描述>#</a></h2>
<h3 id=原有构建速度>原有构建速度<a hidden class=anchor aria-hidden=true href=#原有构建速度>#</a></h3>
<ul>
<li><code>npm run build</code>：打包约50s</li>
<li><code>npm run dev</code>：开启开发模式约50s，保存自动重新编译需约6s，编译完成后需要刷新才能看到效果，偶尔因缓存问题需要再次自动重新编译才能看到效果</li>
</ul>
<h3 id=原有构建结果>原有构建结果<a hidden class=anchor aria-hidden=true href=#原有构建结果>#</a></h3>
<ul>
<li><code>./build/development</code>：存放渲染后的js文件</li>
<li><code>./build/html</code>：存放渲染后的html文件</li>
<li><code>./build/rev</code>：保存各个入口文件hash值的json文件</li>
</ul>
<h3 id=打包代码解析>打包代码解析<a hidden class=anchor aria-hidden=true href=#打包代码解析>#</a></h3>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#75715e>/**
</span><span style=color:#75715e> * 使用gulp-clean插件删除build目录下的文件
</span><span style=color:#75715e> */</span>
<span style=color:#a6e22e>gulp</span>.<span style=color:#a6e22e>task</span>(<span style=color:#e6db74>&#39;clean&#39;</span>, <span style=color:#66d9ef>function</span> () {
    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span><span style=color:#a6e22e>stopClean</span>) {
        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>gulp</span>.<span style=color:#a6e22e>src</span>(<span style=color:#e6db74>&#39;build/&#39;</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>directory</span>, { <span style=color:#a6e22e>read</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>false</span> }).<span style=color:#a6e22e>pipe</span>(<span style=color:#a6e22e>clean</span>())
    }
})
<span style=color:#75715e>/**
</span><span style=color:#75715e> * 使用webpack打包vue与js文件，在clean之后进行
</span><span style=color:#75715e> */</span>
<span style=color:#a6e22e>gulp</span>.<span style=color:#a6e22e>task</span>(<span style=color:#e6db74>&#39;webpack&#39;</span>, [<span style=color:#e6db74>&#39;clean&#39;</span>], <span style=color:#66d9ef>function</span> (<span style=color:#a6e22e>callback</span>) {
    <span style=color:#a6e22e>deCompiler</span>.<span style=color:#a6e22e>run</span>(<span style=color:#66d9ef>function</span> (<span style=color:#a6e22e>err</span>, <span style=color:#a6e22e>stats</span>) {
        <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>err</span>) <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>gutil</span>.<span style=color:#a6e22e>PluginError</span>(<span style=color:#e6db74>&#39;webpack&#39;</span>, <span style=color:#a6e22e>err</span>)
        <span style=color:#a6e22e>gutil</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#39;[webpack]&#39;</span>, <span style=color:#a6e22e>stats</span>.<span style=color:#a6e22e>toString</span>({}))
        <span style=color:#a6e22e>callback</span>()
    })
})
<span style=color:#75715e>/**
</span><span style=color:#75715e> * 使用gulp-uglify插件对js文件进行丑化，在webpack之后进行
</span><span style=color:#75715e> */</span>
<span style=color:#a6e22e>gulp</span>.<span style=color:#a6e22e>task</span>(<span style=color:#e6db74>&#39;minify&#39;</span>, [<span style=color:#e6db74>&#39;webpack&#39;</span>], <span style=color:#66d9ef>function</span> () {
    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>environment</span>) {
        <span style=color:#66d9ef>return</span>
    } <span style=color:#66d9ef>else</span> {
        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>gulp</span>.<span style=color:#a6e22e>src</span>(<span style=color:#e6db74>&#39;build/&#39;</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>directory</span> <span style=color:#f92672>+</span> <span style=color:#e6db74>&#39;/*.js&#39;</span>).<span style=color:#a6e22e>pipe</span>(<span style=color:#a6e22e>uglify</span>())
    }
})
<span style=color:#75715e>/**
</span><span style=color:#75715e> * 使用gulp-rev插件为打包后的文件增加hash，在minify之后运行
</span><span style=color:#75715e> * 
</span><span style=color:#75715e> * gulp-rev会做什么：
</span><span style=color:#75715e> * 根据静态资源内容，生成md5签名，打包出来的文件名会加上md5签名，同时生成一个json用来保存文件名路径对应关系。
</span><span style=color:#75715e> * 替换html里静态资源的路径为带有md5值的文件路径，这样html才能找到资源路径。
</span><span style=color:#75715e> * 有些人可能会做：静态服务器配置静态资源的过期时间为永不过期。
</span><span style=color:#75715e> * 达到什么效果：
</span><span style=color:#75715e> * 静态资源只需请求一次，永久缓存，不会发送协商请求304
</span><span style=color:#75715e> * 版本更新只会更新修改的静态资源内容
</span><span style=color:#75715e> * 不删除旧版本的静态资源，版本回滚的时候只需要更新html，同样不会增加http请求次数
</span><span style=color:#75715e> */</span>
<span style=color:#a6e22e>gulp</span>.<span style=color:#a6e22e>task</span>(<span style=color:#e6db74>&#39;hashJS&#39;</span>, [<span style=color:#e6db74>&#39;minify&#39;</span>], <span style=color:#66d9ef>function</span> () {
    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>dest</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>gulp</span>.<span style=color:#a6e22e>src</span>([<span style=color:#e6db74>&#39;一串入口文件...&#39;</span>])
        .<span style=color:#a6e22e>pipe</span>(<span style=color:#a6e22e>rev</span>()) <span style=color:#75715e>// 设置文件的hash key
</span><span style=color:#75715e></span>        .<span style=color:#a6e22e>pipe</span>(<span style=color:#a6e22e>gulp</span>.<span style=color:#a6e22e>dest</span>(<span style=color:#e6db74>&#39;build/&#39;</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>directory</span>)) <span style=color:#75715e>// 将经过管道处理的文件写出到目录
</span><span style=color:#75715e></span>        .<span style=color:#a6e22e>pipe</span>(<span style=color:#a6e22e>rev</span>.<span style=color:#a6e22e>manifest</span>({})) <span style=color:#75715e>// 生成映射hash key的json
</span><span style=color:#75715e></span>        .<span style=color:#a6e22e>pipe</span>(<span style=color:#a6e22e>gulp</span>.<span style=color:#a6e22e>dest</span>(<span style=color:#e6db74>&#39;build/rev&#39;</span>)) <span style=color:#75715e>// 将经过管道处理的文件写出到目录
</span><span style=color:#75715e></span>    <span style=color:#f92672>!</span><span style=color:#a6e22e>environment</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>gulp</span>.<span style=color:#a6e22e>src</span>([<span style=color:#e6db74>&#39;一串入口文件...&#39;</span>]).<span style=color:#a6e22e>pipe</span>(<span style=color:#a6e22e>clean</span>())
    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>dest</span>
})
<span style=color:#75715e>/**
</span><span style=color:#75715e> * 使用gulp-rev-replace插件为html中引用的js和css替换新的hash
</span><span style=color:#75715e> * 使用gulp-livereload插件在所有文件重新打包完成后局部更新页面
</span><span style=color:#75715e> */</span>
<span style=color:#a6e22e>gulp</span>.<span style=color:#a6e22e>task</span>(<span style=color:#e6db74>&#39;revReplace&#39;</span>, [<span style=color:#e6db74>&#39;hashJS&#39;</span>], <span style=color:#66d9ef>function</span> () {
    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>gulp</span>.<span style=color:#a6e22e>src</span>([<span style=color:#e6db74>&#39;html/*.html&#39;</span>])
        .<span style=color:#a6e22e>pipe</span>(<span style=color:#a6e22e>revReplace</span>({ ... })) <span style=color:#75715e>// 给html中的js引用提供新的hash
</span><span style=color:#75715e></span>        .<span style=color:#a6e22e>pipe</span>(<span style=color:#a6e22e>gulp</span>.<span style=color:#a6e22e>dest</span>(<span style=color:#e6db74>&#39;build/html&#39;</span>)) <span style=color:#75715e>// 输出文件
</span><span style=color:#75715e></span>        .<span style=color:#a6e22e>pipe</span>(<span style=color:#a6e22e>livereload</span>()) <span style=color:#75715e>// 局部更新页面
</span><span style=color:#75715e></span>})
<span style=color:#75715e>/**
</span><span style=color:#75715e> * 使用gulp.watch，当应用程序目录下有任何文件发生改变，则重新执行一遍打包命令
</span><span style=color:#75715e> * gulp.watch：监视文件，并且可以在文件发生改动时候做一些事情。
</span><span style=color:#75715e> */</span>
<span style=color:#a6e22e>gulp</span>.<span style=color:#a6e22e>task</span>(<span style=color:#e6db74>&#39;watch&#39;</span>, [<span style=color:#e6db74>&#39;revReplace&#39;</span>], <span style=color:#66d9ef>function</span> () {
    <span style=color:#a6e22e>stopClean</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>
    <span style=color:#a6e22e>livereload</span>.<span style=color:#a6e22e>listen</span>()
    <span style=color:#a6e22e>gulp</span>.<span style=color:#a6e22e>watch</span>(<span style=color:#e6db74>&#39;app/**/*&#39;</span>, [<span style=color:#e6db74>&#39;clean&#39;</span>, <span style=color:#e6db74>&#39;webpack&#39;</span>, <span style=color:#e6db74>&#39;minify&#39;</span>, <span style=color:#e6db74>&#39;hashJS&#39;</span>, <span style=color:#e6db74>&#39;revReplace&#39;</span>])
})
<span style=color:#75715e>/**
</span><span style=color:#75715e> * 输出dev和build的工作流
</span><span style=color:#75715e> */</span>
<span style=color:#a6e22e>gulp</span>.<span style=color:#a6e22e>task</span>(<span style=color:#e6db74>&#39;default&#39;</span>, [<span style=color:#e6db74>&#39;clean&#39;</span>, <span style=color:#e6db74>&#39;webpack&#39;</span>, <span style=color:#e6db74>&#39;minify&#39;</span>, <span style=color:#e6db74>&#39;hashJS&#39;</span>, <span style=color:#e6db74>&#39;revReplace&#39;</span>, <span style=color:#e6db74>&#39;watch&#39;</span>]) <span style=color:#75715e>// dev
</span><span style=color:#75715e></span><span style=color:#a6e22e>gulp</span>.<span style=color:#a6e22e>task</span>(<span style=color:#e6db74>&#39;build&#39;</span>, [<span style=color:#e6db74>&#39;clean&#39;</span>, <span style=color:#e6db74>&#39;webpack&#39;</span>, <span style=color:#e6db74>&#39;minify&#39;</span>, <span style=color:#e6db74>&#39;hashJS&#39;</span>, <span style=color:#e6db74>&#39;revReplace&#39;</span>]) <span style=color:#75715e>// build
</span><span style=color:#75715e></span><span style=color:#75715e>/**
</span><span style=color:#75715e> * webpack配置
</span><span style=color:#75715e> */</span>
<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>devCompiler</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>webpack</span>({
    <span style=color:#a6e22e>entry</span><span style=color:#f92672>:</span> {
        ... <span style=color:#75715e>// 一众入口文件
</span><span style=color:#75715e></span>        <span style=color:#a6e22e>vendor</span><span style=color:#f92672>:</span> [<span style=color:#e6db74>&#39;vue&#39;</span>, <span style=color:#e6db74>&#39;vue-router&#39;</span>, <span style=color:#e6db74>&#39;lodash&#39;</span>, <span style=color:#e6db74>&#39;echarts&#39;</span>] <span style=color:#75715e>// 公共模块
</span><span style=color:#75715e></span>    },
    <span style=color:#a6e22e>output</span><span style=color:#f92672>:</span> {
        <span style=color:#a6e22e>path</span><span style=color:#f92672>:</span> ..., <span style=color:#75715e>// 所有输出文件的目标路径
</span><span style=color:#75715e></span>        <span style=color:#a6e22e>publicPath</span><span style=color:#f92672>:</span> ..., <span style=color:#75715e>// 输出解析文件的目录
</span><span style=color:#75715e></span>        <span style=color:#a6e22e>filename</span><span style=color:#f92672>:</span> ..., <span style=color:#75715e>// 输出文件
</span><span style=color:#75715e></span>        <span style=color:#a6e22e>chunkFilename</span><span style=color:#f92672>:</span> ... <span style=color:#75715e>// 通过异步请求的文件
</span><span style=color:#75715e></span>    },
    <span style=color:#75715e>// 排除以下内容打包到 bundle，减小文件大小
</span><span style=color:#75715e></span>    <span style=color:#a6e22e>external</span><span style=color:#f92672>:</span> {
        <span style=color:#a6e22e>jquery</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;jQuery&#39;</span>,
        <span style=color:#a6e22e>dialog</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;dialog&#39;</span>
    },
    <span style=color:#a6e22e>plugins</span><span style=color:#f92672>:</span> [
        <span style=color:#75715e>/**
</span><span style=color:#75715e>         * 通过将公共模块拆出来，最终合成的文件能够在最开始的时候加载一次，便存到缓存中供后续使用。
</span><span style=color:#75715e>         * 这个带来页面速度上的提升，因为浏览器会迅速将公共的代码从缓存中取出来，而不是每次访问一个新页面时，再去加载一个更大的文件。
</span><span style=color:#75715e>         */</span>
        <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>webpack</span>.<span style=color:#a6e22e>optimize</span>.<span style=color:#a6e22e>CommonsChunkPlugin</span>({
            <span style=color:#a6e22e>name</span><span style=color:#f92672>:</span> [<span style=color:#e6db74>&#39;vendor&#39;</span>]
        }),
        <span style=color:#75715e>/**
</span><span style=color:#75715e>         * DefinePlugin 允许创建一个在编译时可以配置的全局常量。这可能会对开发模式和生产模式的构建允许不同的行为非常有用。
</span><span style=color:#75715e>         */</span>
        <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>webpack</span>.<span style=color:#a6e22e>DefinePlugin</span>({
            <span style=color:#ae81ff>__</span><span style=color:#a6e22e>VERSION__</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>new</span> Date().<span style=color:#a6e22e>getTime</span>()
        })
    ],
    <span style=color:#a6e22e>resolve</span><span style=color:#f92672>:</span> {
        <span style=color:#a6e22e>root</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>__</span><span style=color:#a6e22e>dirname</span>,
        <span style=color:#a6e22e>extensions</span><span style=color:#f92672>:</span> [<span style=color:#e6db74>&#39;&#39;</span>, <span style=color:#e6db74>&#39;.js&#39;</span>, <span style=color:#e6db74>&#39;.vue&#39;</span>, <span style=color:#e6db74>&#39;.json&#39;</span>], <span style=color:#75715e>// 解析组件的文件后缀白名单
</span><span style=color:#75715e></span>        <span style=color:#a6e22e>alias</span><span style=color:#f92672>:</span> { ... } <span style=color:#75715e>// 配置路径别名
</span><span style=color:#75715e></span>    },
    <span style=color:#a6e22e>module</span><span style=color:#f92672>:</span> {
        <span style=color:#75715e>// 各个文件的loaders
</span><span style=color:#75715e></span>        <span style=color:#a6e22e>loaders</span><span style=color:#f92672>:</span> [
            { <span style=color:#a6e22e>test</span><span style=color:#f92672>:</span> <span style=color:#e6db74>/\.vue$/</span>, <span style=color:#a6e22e>loader</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;vue-loader&#39;</span> },
            { <span style=color:#a6e22e>test</span><span style=color:#f92672>:</span> <span style=color:#e6db74>/\.css$/</span>, <span style=color:#a6e22e>loader</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;style-loader!css-loader&#39;</span> },
            { <span style=color:#a6e22e>test</span><span style=color:#f92672>:</span> <span style=color:#e6db74>/\.jsx$/</span>, <span style=color:#a6e22e>loader</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;babel-loader&#39;</span>, <span style=color:#a6e22e>include</span><span style=color:#f92672>:</span> [<span style=color:#a6e22e>path</span>.<span style=color:#a6e22e>join</span>(<span style=color:#ae81ff>__</span><span style=color:#a6e22e>dirname</span>, <span style=color:#e6db74>&#39;app&#39;</span>)], <span style=color:#a6e22e>exclude</span><span style=color:#f92672>:</span> <span style=color:#e6db74>/core/</span> },
            { <span style=color:#a6e22e>test</span><span style=color:#f92672>:</span> <span style=color:#e6db74>/\.json$/</span>, <span style=color:#a6e22e>loader</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;json&#39;</span> }
        ]
    },
    <span style=color:#a6e22e>vue</span><span style=color:#f92672>:</span> {
        <span style=color:#a6e22e>loaders</span><span style=color:#f92672>:</span> {
            <span style=color:#a6e22e>js</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;babel-loader&#39;</span>
        }
    }
})
</code></pre></div><h2 id=2-将gulp的功能移到webpack1上执行>2. 将<code>Gulp</code>的功能移到<code>Webpack1</code>上执行<a hidden class=anchor aria-hidden=true href=#2-将gulp的功能移到webpack1上执行>#</a></h2>
<h3 id=使用html-webpack-plugin插件构建项目的主html文件>使用<code>html-webpack-plugin</code>插件构建项目的主<code>.html</code>文件<a hidden class=anchor aria-hidden=true href=#使用html-webpack-plugin插件构建项目的主html文件>#</a></h3>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#a6e22e>module</span>.<span style=color:#a6e22e>exports</span> <span style=color:#f92672>=</span> {
    <span style=color:#a6e22e>plugins</span><span style=color:#f92672>:</span> [
        <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>HtmlWebpackPlugin</span>({
            <span style=color:#a6e22e>filename</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;...&#39;</span>, <span style=color:#75715e>// 输出的路径
</span><span style=color:#75715e></span>            <span style=color:#a6e22e>template</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;...&#39;</span>, <span style=color:#75715e>// 提取源html的路径
</span><span style=color:#75715e></span>            <span style=color:#a6e22e>chunks</span><span style=color:#f92672>:</span> [<span style=color:#e6db74>&#39;...&#39;</span>], <span style=color:#75715e>// 需要导入的模块
</span><span style=color:#75715e></span>            <span style=color:#a6e22e>inject</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>true</span> <span style=color:#75715e>// 是否附加到body底部
</span><span style=color:#75715e></span>        })
    ]
}
</code></pre></div><h3 id=使用webpackoptimizeuglifyjsplugin插件进行js压缩>使用<code>webpack.optimize.UglifyJsPlugin</code>插件进行<code>JS</code>压缩<a hidden class=anchor aria-hidden=true href=#使用webpackoptimizeuglifyjsplugin插件进行js压缩>#</a></h3>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#a6e22e>module</span>.<span style=color:#a6e22e>exports</span> <span style=color:#f92672>=</span> {
    <span style=color:#a6e22e>plugins</span><span style=color:#f92672>:</span> [
        <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>webpack</span>.<span style=color:#a6e22e>optimize</span>.<span style=color:#a6e22e>UglifyJsPlugin</span>({
            <span style=color:#a6e22e>compress</span><span style=color:#f92672>:</span> { <span style=color:#a6e22e>warnings</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>false</span> }
        })
    ]
}
</code></pre></div><h3 id=使用webpack-dev-server模块提供node搭建的开发环境>使用<code>webpack-dev-server</code>模块，提供<code>node</code>搭建的开发环境<a hidden class=anchor aria-hidden=true href=#使用webpack-dev-server模块提供node搭建的开发环境>#</a></h3>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#a6e22e>module</span>.<span style=color:#a6e22e>exports</span> <span style=color:#f92672>=</span> {
    <span style=color:#a6e22e>devServer</span><span style=color:#f92672>:</span> {
        <span style=color:#a6e22e>clientLogLevel</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;warning&#39;</span>, <span style=color:#75715e>// 输出日志的级别，配置为警告级别以上才输出
</span><span style=color:#75715e></span>        <span style=color:#a6e22e>inline</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>true</span>, <span style=color:#75715e>// 启动 live reload
</span><span style=color:#75715e></span>        <span style=color:#a6e22e>hot</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>true</span>, <span style=color:#75715e>// 允许启用热重载
</span><span style=color:#75715e></span>        <span style=color:#a6e22e>compress</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>true</span>, <span style=color:#75715e>// 对所有静态资源进行gzip压缩
</span><span style=color:#75715e></span>        <span style=color:#a6e22e>open</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>true</span>, <span style=color:#75715e>// 默认在启动本地服务时打开浏览器
</span><span style=color:#75715e></span>        <span style=color:#a6e22e>quiet</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>true</span>, <span style=color:#75715e>// 禁止输出繁杂的构建日志
</span><span style=color:#75715e></span>        <span style=color:#a6e22e>host</span><span style=color:#f92672>:</span> ..., <span style=color:#75715e>// 服务启动的域名
</span><span style=color:#75715e></span>        <span style=color:#a6e22e>port</span><span style=color:#f92672>:</span> ..., <span style=color:#75715e>// 服务启动的端口
</span><span style=color:#75715e></span>        <span style=color:#a6e22e>proxy</span><span style=color:#f92672>:</span> { ... }, <span style=color:#75715e>// http代理配置
</span><span style=color:#75715e></span>        <span style=color:#75715e>/**
</span><span style=color:#75715e>         * 这个配置常用于解决spa应用h5路由模式下将所有404路由匹配回index.html的问题
</span><span style=color:#75715e>         * 由于生产环境为主页匹配了一个比较简单的别名，因此开发环境也照搬后端服务的配置
</span><span style=color:#75715e>         */</span>
        <span style=color:#a6e22e>historyApiFallback</span><span style=color:#f92672>:</span> {
            <span style=color:#a6e22e>rewrites</span><span style=color:#f92672>:</span> [{ <span style=color:#a6e22e>from</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;/^\/admin/&#39;</span>, <span style=color:#a6e22e>to</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;...&#39;</span> }]
        }
    }
}
</code></pre></div><h3 id=踩坑>踩坑<a hidden class=anchor aria-hidden=true href=#踩坑>#</a></h3>
<ol>
<li><code>webpack-dev-server@3.2.1 requires a peer of webpack^@4.0.0 but none is installed.</code>：这两个模块版本不兼容，回退到<code>webpack-dev-server@2</code>成功运行。</li>
<li><code>Cannot resolve module 'fsevents' ...</code>：将全局的<code>webpack</code>调用改为直接从<code>node_modules/webpack</code>下直接调用，解决了问题，<code>node node_modules/webpack/bin/webpack.js --config webpack.config.js</code>。</li>
<li><code>Cannot resolve module 'fs' ...</code>：配置<code>config.node.fs = 'empty'</code>，为<code>Webpack</code>提供<code>node</code>原生模块，使其能加载到这个对象。</li>
<li>热重载只对<code>.js</code>和<code>.css</code>及<code>.vue</code>中的<code>&lt;style></code>内样式生效，对<code>.vue</code>文件中的<code>html</code>模板及<code>js</code>内容都不生效，会打印“模块代码已发生改变并重新编译，但热重载不生效，可能会启用全局刷新的策略”之类的信息，暂时没有解决，初步判断是低版本的<code>vue-hot-reload-api</code>对这些部分的处理有问题，有大神了解原理可以在评论区科普一哈=.=。</li>
</ol>
<h2 id=3-从webpack1升级到webpack3>3. 从<code>Webpack1</code>升级到<code>Webpack3</code><a hidden class=anchor aria-hidden=true href=#3-从webpack1升级到webpack3>#</a></h2>
<p>由于<code>Webpack2</code>与<code>Webpack3</code>几乎完全兼容，只是涉及到一些增量的功能，因此选择直接从<code>Webpack1</code>迁移到<code>Webapck3</code>，先在项目中安装<code>Webpack3</code>，然后根据<code>Webpack2</code>文档中《从<code>Webpack1</code>迁移》的章节，对配置项进行更改，参考的文档戳这个：https://www.html.cn/doc/webpack2/guides/migrating/</p>
<p>这次升级没有遇到什么问题，根据文档配置稍作更改就跑通了。梳理一下目前为止实现的功能：</p>
<ol>
<li>新的<code>Webpack</code>构建代码已经实现了原有的所有功能，下面列举新增的功能。</li>
<li>使用<code>webpack-dev-server</code>作为开发服务器，实现了保存时<code>live reload</code>的功能。</li>
<li>使用<code>http-proxy-middleware</code>插件，将请求直接代理到测试服，让开发环境脱离了本地部署的后端服务，大大降低了开发环境部署的时间成本。</li>
<li>新增<code>friendly-errors-webpack-plugin</code>，输出友好的构建日志，打印几个重要模块的开发环境地址，配置方面完全参考了<code>vue-cli@2</code>的默认配置。</li>
<li>新增<code>postcss-loader</code>，对css添加兼容处理，配置方面完全参考了<code>vue-cli@2</code>的默认配置。</li>
<li>使用<code>webpack.optimize.UglifyJsPlugin</code>压缩js代码。</li>
</ol>
<p>尝试进行构建，输出构建时间记录：</p>
<ul>
<li><code>npm run build</code>：约<code>135s</code></li>
<li><code>npm run dev</code>：初次构建约<code>58s</code>，持续构建约<code>30s</code></li>
</ul>
<p>项目构建时间过长（第一次打包把自己吓了一跳&mldr;），只能继续寻求构建速度上的优化</p>
<h2 id=4-在webpack3下进行构建速度的优化>4. 在<code>Webpack3</code>下进行构建速度的优化<a hidden class=anchor aria-hidden=true href=#4-在webpack3下进行构建速度的优化>#</a></h2>
<h3 id=使用webpack-jarvis监测构建性能>使用<code>webpack-jarvis</code>监测构建性能<a hidden class=anchor aria-hidden=true href=#使用webpack-jarvis监测构建性能>#</a></h3>
<p><code>webpack-jarvis</code>是一个图形化的webpack性能监测工具，它配置简便，对构建过程的时间占比、构建结果的详细记录都有具体的输出</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#75715e>// 经过简单的配置就可以在本地3001端口输出构建结果记录
</span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>Jarvis</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>require</span>(<span style=color:#e6db74>&#39;webpack-jarvis&#39;</span>)
<span style=color:#a6e22e>module</span>.<span style=color:#a6e22e>exports</span> <span style=color:#f92672>=</span> {
    <span style=color:#a6e22e>plugins</span><span style=color:#f92672>:</span> [
        <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>Jarvis</span>({
            <span style=color:#a6e22e>watchOnly</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>false</span>,
            <span style=color:#a6e22e>port</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>3001</span>
        })
    ]
}
</code></pre></div><h3 id=使用happypack>使用<code>happypack</code><a hidden class=anchor aria-hidden=true href=#使用happypack>#</a></h3>
<p>先根据网上搜到的文章，做一些简单的优化，如使用<code>happypack</code>，这个模块通过多进程模型，来加速代码构建，但是使用之后貌似没有太明显的结果，构建时间大概减少了几秒吧&mldr;暂时还不太懂这个模块对优化什么场景的效果比较明显，之前有看到一篇讲解<code>happypack</code>原理的文章，但还没细看，有兴趣小伙伴可以研究一下，要是能在评论里简洁明了的给渣渣楼主解释一下就更好了TUT：http://taobaofed.org/blog/2016/12/08/happypack-source-code-analysis/</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>HappyPack</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>require</span>(<span style=color:#e6db74>&#39;happypack&#39;</span>)
<span style=color:#66d9ef>const</span> <span style=color:#a6e22e>os</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>require</span>(<span style=color:#e6db74>&#39;os&#39;</span>)
<span style=color:#66d9ef>const</span> <span style=color:#a6e22e>happyThreadPool</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>HappyPack</span>.<span style=color:#a6e22e>ThreadPool</span>({ <span style=color:#a6e22e>size</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>os</span>.<span style=color:#a6e22e>cpus</span>().<span style=color:#a6e22e>length</span> })
<span style=color:#a6e22e>module</span>.<span style=color:#a6e22e>exports</span> <span style=color:#f92672>=</span> {
    <span style=color:#a6e22e>plugins</span><span style=color:#f92672>:</span> [
        <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>HappyPack</span>({
            <span style=color:#75715e>// happypack的id，在调用时需要声明，若需要编译其他类型的文件需要再声明一个happypack
</span><span style=color:#75715e></span>            <span style=color:#a6e22e>id</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;js&#39;</span>,
            <span style=color:#75715e>// cacheDirectory：设置后，将尽量在babel编译时使用缓存加载器的结果，避免重新走一遍babel的高昂代价
</span><span style=color:#75715e></span>            <span style=color:#a6e22e>use</span><span style=color:#f92672>:</span> [{ <span style=color:#a6e22e>loader</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;babel-loader&#39;</span>, <span style=color:#a6e22e>cacheDirectory</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>true</span> }],
            <span style=color:#75715e>// 根据cpu的核心数判断需要拆分多少个进程池
</span><span style=color:#75715e></span>            <span style=color:#a6e22e>threadPool</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>happyThreadPool</span>,
            <span style=color:#75715e>// 是否输出编译过程的日志
</span><span style=color:#75715e></span>            <span style=color:#a6e22e>verbose</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>true</span>
        })
    ]
}
</code></pre></div><p>做完这一步后，输出构建时间记录：</p>
<ul>
<li><code>npm run build</code>：约<code>130s</code></li>
<li><code>npm run dev</code>：初次构建约<code>60s</code>，持续构建约<code>30s</code></li>
</ul>
<h3 id=devtool配置为cheap-module-eval-source-map><code>devtool</code>配置为<code>cheap-module-eval-source-map</code><a hidden class=anchor aria-hidden=true href=#devtool配置为cheap-module-eval-source-map>#</a></h3>
<p><code>devtool</code>选项启用<code>cheap-module-eval-source-map</code>模式：<code>vue-cli@2</code>默认配置为这种模式，<code>cheap</code>代表在输出<code>source-map</code>时省略列信息；<code>module</code>表示在编译过程中启用如<code>babel-loader</code>这样的预编译器，使得调试时可以直接看到未经编译的源代码；<code>eval</code>表示启用<code>eval</code>模式编译，该模式直接使用<code>eval</code>函数执行编译后模块的字符串，减少了将字符串转化为可执行的代码文件这个步骤，加快了项目开发中重建的速度；<code>source-map</code>表示输出源代码的映射表，使得开发时可以直接把错误定位到源代码，提高开发效率。</p>
<p>做完这一步后，效果并不明显=.=（相比原来的<code>source-map</code>），大概减少了几秒，输出构建时间记录：</p>
<ul>
<li><code>npm run build</code>：约<code>130s</code></li>
<li><code>npm run dev</code>：初次构建约<code>58s</code>，持续构建约<code>30s</code></li>
</ul>
<h3 id=使用html-webpack-plugin-for-multihtml提升多入口项目重建速度>使用<code>html-webpack-plugin-for-multihtml</code>提升多入口项目重建速度<a hidden class=anchor aria-hidden=true href=#使用html-webpack-plugin-for-multihtml提升多入口项目重建速度>#</a></h3>
<p>重建一次竟然需要<code>30s</code>！各种搜索找到了<code>html-webpack-plugin</code>的一条<code>issue</code>，发现<code>html-webpack-plugin@2</code>在构建多入口应用时速度确实有明显变慢的情况，原因是没有成功的对构建内容进行缓存，使每次重建都重新编译所有代码。作者给出的解决方案是使用这个模块的一个分支项目（是由作者本人<code>fork</code>原项目并针对这个问题进行修复的项目）<code>html-webpack-plugin-for-multihtml</code>，用法与<code>html-webpack-plugin</code>完全相同，使用之后重建仅需<code>1s</code>左右。</p>
<p>做完这一步后，输出构建时间记录：</p>
<ul>
<li><code>npm run build</code>：约<code>130s</code></li>
<li><code>npm run dev</code>：初次构建约<code>58s</code>，持续构建约<code>1s</code></li>
</ul>
<h3 id=使用webpackdllplugin提取公共模块>使用<code>webpack.DllPlugin</code>提取公共模块<a hidden class=anchor aria-hidden=true href=#使用webpackdllplugin提取公共模块>#</a></h3>
<p>在输出结果中找到了不少较大的依赖包，如<code>Vue</code>的核心库、<code>lodash</code>、<code>echarts</code>等等，还有一些不希望被打包的静态资源，想办法避免每次都编译这些内容，提升编译速度，所以找到了这个插件。</p>
<p><code>webpack.DllPlugin</code>这个插件是来源于<code>Windows</code>系统的<code>.dll</code>文件（动态链接库）的用法：首先通过<code>DllPlugin</code>模块构建出一个包含公共模块的包和一个映射表，再通过<code>DllReferencePlugin</code>模块通过映射表给每个模块关联对应的依赖，这样可以对这些公共模块进行预先打包，以后构建的时候就不需要处理这些模块，减少打包时间。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#75715e>// webpack.dll.conf.js
</span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>webpack</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>require</span>(<span style=color:#e6db74>&#39;webpack&#39;</span>)
<span style=color:#a6e22e>module</span>.<span style=color:#a6e22e>exports</span> <span style=color:#f92672>=</span> {
    <span style=color:#a6e22e>entry</span><span style=color:#f92672>:</span> {
        <span style=color:#a6e22e>vendor</span><span style=color:#f92672>:</span> [...]
    },
    <span style=color:#a6e22e>output</span><span style=color:#f92672>:</span> {
        <span style=color:#a6e22e>path</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>resolve</span>(<span style=color:#e6db74>&#39;build/development&#39;</span>),
        <span style=color:#a6e22e>filename</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;[name].dll.js&#39;</span>,
        <span style=color:#a6e22e>library</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;[name]_library&#39;</span>
    },
    <span style=color:#a6e22e>plugins</span><span style=color:#f92672>:</span> [
        <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>webpack</span>.<span style=color:#a6e22e>optimize</span>.<span style=color:#a6e22e>UglifyJsPlugin</span>(),
        <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>webpack</span>.<span style=color:#a6e22e>DllPlugin</span>({
            <span style=color:#a6e22e>path</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>resolve</span>(<span style=color:#e6db74>&#39;build/development/[name]-manifest.json&#39;</span>), <span style=color:#75715e>// 生成manifest文件输出的位置和文件名称
</span><span style=color:#75715e></span>            <span style=color:#a6e22e>name</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;[name]-library&#39;</span>, <span style=color:#75715e>// 与output.library是一样的，对应manifest.json文件中name字段的值，防止全局变量冲突
</span><span style=color:#75715e></span>            <span style=color:#a6e22e>context</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>__</span><span style=color:#a6e22e>dirname</span>
        })
    ]
}
<span style=color:#75715e>// webpack.base.conf.js
</span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>webpack</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>require</span>(<span style=color:#e6db74>&#39;webpack&#39;</span>)
<span style=color:#a6e22e>module</span>.<span style=color:#a6e22e>exports</span> <span style=color:#f92672>=</span> {
    <span style=color:#a6e22e>plugins</span><span style=color:#f92672>:</span> [
        <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>webpack</span>.<span style=color:#a6e22e>DllReferencePlugin</span>({
            <span style=color:#a6e22e>context</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>__</span><span style=color:#a6e22e>dirname</span>,
            <span style=color:#a6e22e>manifest</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>require</span>(<span style=color:#e6db74>&#39;../build/development/vendor-manifest.json&#39;</span>) <span style=color:#75715e>// 让webpack从映射表获取使用的依赖
</span><span style=color:#75715e></span>        })
    ]
}
</code></pre></div><p>打包出来之后还需要在html文件中引入公共库<code>vendor.dll.js</code>文件</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-html data-lang=html>&lt;<span style=color:#f92672>html</span>&gt;
    &lt;<span style=color:#f92672>head</span>&gt;&lt;/<span style=color:#f92672>head</span>&gt;
    &lt;<span style=color:#f92672>body</span>&gt;
        &lt;<span style=color:#f92672>div</span> <span style=color:#a6e22e>id</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;app&#34;</span>&gt;&lt;/<span style=color:#f92672>div</span>&gt;
        &lt;<span style=color:#f92672>script</span> <span style=color:#a6e22e>src</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;/build/development/vendor.dll.js&#34;</span>&gt;&lt;/<span style=color:#f92672>script</span>&gt;
        <span style=color:#75715e>&lt;!-- 其他JS应该注入到dll的后面，确保能够引用到公共库的内容 --&gt;</span>
    &lt;/<span style=color:#f92672>body</span>&gt;
&lt;/<span style=color:#f92672>html</span>&gt;
</code></pre></div><p>做完这一步后，输出构建时间记录，发现构建效率有了明显的提高：</p>
<ul>
<li><code>npm run dll</code>：约<code>25s</code></li>
<li><code>npm run build</code>：约<code>70s</code></li>
<li><code>npm run dev</code>：初次构建约<code>55s</code>，持续构建约<code>1s</code></li>
</ul>
<h2 id=5-后记>5. 后记<a hidden class=anchor aria-hidden=true href=#5-后记>#</a></h2>
<p>优化到这里就差不多结束，这次的优化为旧项目提供了新一代<code>spa</code>项目应有的一些功能，搭建了更现代的本地开发环境。由于本文篇幅有点太长，完整的配置就丢在<a href=https://github.com/yyj08070631/yyj/blob/master/Vue/Vue1.0+Webpack1+Gulp项目升级构建方案的踩坑路-完整配置.md target=_blank>另一篇文章</a>里。</p>
<h2 id=6-qa>6. Q&A<a hidden class=anchor aria-hidden=true href=#6-qa>#</a></h2>
<p>Q: 为什么不直接升级到<code>Webpack4</code>？</p>
<p>A: <code>Webpack4</code>只支持<code>vue-loader@15</code>以上版本，而这个版本已经无法解析<code>Vue1</code>的文件。</p>
</div>
<footer class=post-footer>
<ul class=post-tags>
<li><a href=https://geekhouse.top/tags/engineering/>Engineering</a></li>
</ul>
<nav class=paginav>
<a class=prev href=https://geekhouse.top/posts/algorithm_sort/>
<span class=title>« Prev Page</span>
<br>
<span>排序算法</span>
</a>
</nav>
</footer>
</article>
</main>
<footer class=footer>
<span>&copy; 2021 <a href=https://geekhouse.top/>GeekHouse</a></span>
<span>
Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a>
</span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a>
<script>let menu=document.getElementById('menu');menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
<script>document.querySelectorAll('pre > code').forEach(b=>{const c=b.parentNode.parentNode,a=document.createElement('button');a.classList.add('copy-code'),a.innerText='copy';function d(){a.innerText='copied!',setTimeout(()=>{a.innerText='copy'},2e3)}a.addEventListener('click',e=>{if('clipboard'in navigator){navigator.clipboard.writeText(b.textContent),d();return}const a=document.createRange();a.selectNodeContents(b);const c=window.getSelection();c.removeAllRanges(),c.addRange(a);try{document.execCommand('copy'),d()}catch(a){}c.removeRange(a)}),c.classList.contains("highlight")?c.appendChild(a):c.parentNode.firstChild==c||(b.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?b.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(a):b.parentNode.appendChild(a))})</script>
</body>
</html>