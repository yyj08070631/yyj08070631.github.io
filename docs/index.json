[{"categories":null,"contents":"基本介绍 作为算法题的一个大类，位运算相关的题目常常出现在各大公司的面试/笔试题中，下面先说说位运算的基本原理。\n位运算使得计算机可以直接对每个比特位进行计算，效率会非常的高。\n在 JS 中，位运算会将操作数当作 32 位的二进制串进行计算，如果二进制串超过 32 位，则只保留最后的 32 位进行计算，如：\n11100110111110100000000000000110000000000001 # 输入的二进制串 10100000000000000110000000000001 # 实际使用的二进制串 在 JS 中，位运算有 7 种运算符：\n 按位与（a \u0026amp; b）：在 a, b 的位表示中，每一个对应的位都为 1 则返回 1，否则返回 0  # 15 \u0026amp; 9 -\u0026gt; 9 0000 0000 0000 0000 0000 0000 0000 1111 \u0026amp; 0000 0000 0000 0000 0000 0000 0000 1001 --------------------------------------- 0000 0000 0000 0000 0000 0000 0000 1001 按位或（a | b）：在 a, b 的位表示中，每一个对应的位，只要有一个为 1 则返回 1，否则返回 0  # 15 | 9 -\u0026gt; 15 0000 0000 0000 0000 0000 0000 0000 1111 | 0000 0000 0000 0000 0000 0000 0000 1001 --------------------------------------- 0000 0000 0000 0000 0000 0000 0000 1111 按位异或（a ^ b）：在 a, b 的位表示中，每一个对应的位，两个不相同则返回 1，相同则返回 0  # 15 ^ 9 -\u0026gt; 6 0000 0000 0000 0000 0000 0000 0000 1111 | 0000 0000 0000 0000 0000 0000 0000 1001 --------------------------------------- 0000 0000 0000 0000 0000 0000 0000 0110 按位非（~a）：反转被操作数的位，即将每一位的 0 转为 1，1 转为 0  # ~15 -\u0026gt; -16 ~ 0000 0000 0000 0000 0000 0000 0000 1111 --------------------------------------- 1111 1111 1111 1111 1111 1111 1111 0000 左移（a \u0026laquo; b）：将 a 的二进制串向左移动 b 位，右边移入 0  # 9 \u0026lt;\u0026lt; 2 -\u0026gt; 36 \u0026lt;\u0026lt; 0000 0000 0000 0000 0000 0000 0000 1001 --------------------------------------- 0000 0000 0000 0000 0000 0000 0010 0100 有符号右移（a \u0026raquo; b）：把 a 的二进制表示向右移动 b 位，向右被移出的位被丢弃，拷贝最左侧的位以填充左侧。这种右移由于保留最左侧的二进制位，因此可以保留数字原本的正负符号  # 9 \u0026gt;\u0026gt; 2 -\u0026gt; 2 \u0026gt;\u0026gt; 0000 0000 0000 0000 0000 0000 0000 1001 --------------------------------------- 0000 0000 0000 0000 0000 0000 0010 0010 # -9 \u0026gt;\u0026gt; 2 -\u0026gt; -3 \u0026gt;\u0026gt; 1111 1111 1111 1111 1111 1111 1111 0111 --------------------------------------- 1111 1111 1111 1111 1111 1111 1111 1101 无符号右移（a \u0026raquo;\u0026gt; b）：把 a 的二进制表示向右移动 b 位，向右被移出的位被丢弃，左边空出的位全部填充为 0。这种右移由于左侧直接补 0，因此生成的数字必然是非负数  # 19 \u0026gt;\u0026gt;\u0026gt; 2 -\u0026gt; 4 \u0026gt;\u0026gt;\u0026gt; 0000 0000 0000 0000 0000 0000 0001 0011 --------------------------------------- 0000 0000 0000 0000 0000 0000 0010 0010 # -19 \u0026gt;\u0026gt;\u0026gt; 2 -\u0026gt; 1073741819 \u0026gt;\u0026gt;\u0026gt; 1111 1111 1111 1111 1111 1111 1110 1101 --------------------------------------- 0011 1111 1111 1111 1111 1111 1111 0011 常用性质 在使用位运算技巧解的算法题中，有以下这些常用的性质：\n a 与自身之间的操作  a \u0026amp; a = a a | a = a a ^ a = 0 a 与 0 之间的操作  a \u0026amp; 0 = 0 a | 0 = a a ^ 0 = a 按位与、按位或的还原计算  a | ( a \u0026amp; b ) = a a \u0026amp; ( a | b ) = a 通过异或完成变量值交换  a ^= b b ^= a a ^= b 判断奇偶（通过 \u0026amp; 1 取出最后一个二进制位以达到模 2 的效果）  # 位运算效率更高 a \u0026amp; 1 === a % 2 比较两值是否相等（a ^ a === 0）  a ^ b === 0 将第 i + 1 个二进制位设为 1  a |= 1 \u0026lt;\u0026lt; i 将第 i + 1 个二进制位设为 0  a \u0026amp;= ~(1 \u0026lt;\u0026lt; i) 取出第 i + 1 个二进制位上的数值  a \u0026amp; (1 \u0026lt;\u0026lt; i) 在 a 第 i + 1 个二进制位，插入 b 对应位置的二进制位  a |= 1 \u0026lt;\u0026lt; i a \u0026amp; (b \u0026amp; 1 \u0026lt;\u0026lt; i) 删除二进制序列中最后一个值为 1 的位置  a \u0026amp;= (a - 1) 计算 a 的相反数  -a === ~a + 1 保留 a 在二进制位中最后一个 1  a \u0026amp;= (-a) 生成二进制位全为 1 的数  ~0 保留 a 二进制序列中最后的 i - 1 位，其余补 0  a \u0026amp; ((1 \u0026lt;\u0026lt; i) - 1) 将 a 二进制序列中最后 i - 1 位全部置为 0  a \u0026amp; ~((1 \u0026lt;\u0026lt; i) - 1) 判断 a 的二进制序列最高位是否为 1  a \u0026lt; 0 # 最高位为 1 必然是负数 在二进制序列中，仅保留最高位的 1，其他设为 0，输出该数  a = a | (a \u0026gt;\u0026gt; 1) a = a | (a \u0026gt;\u0026gt; 2) a = a | (a \u0026gt;\u0026gt; 4) a = a | (a \u0026gt;\u0026gt; 8) a = a | (a \u0026gt;\u0026gt; 16) return (a + 1) \u0026gt;\u0026gt; 1 下面，我们通过一些 简单-中等 的题目来体验一下位运算解题的巧妙。\n题目 78 - 子集 https://leetcode-cn.com/problems/subsets\n给你一个整数数组 nums，数组中的元素互不相同。返回该数组所有可能的子集（幂集）。\n解集不能包含重复的子集。你可以按任意顺序返回解集。\n示例 1：\n输入： nums = [1,2,3]\n输出： [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]\n从位运算出发去思考，如果用 0 和 1 标记一个数是否存在于子集中，这样列下来，例子中的输入 [1,2,3] 就会产生下表所示的子集与 0/1 序列的关系，因此我们可以直接遍历这个 0/1 序列，去构建每个子集的数据。\n   0/1序列 子集 0/1序列对应的二进制数     000 {} 0   001 {3} 1   010 {2} 2   011 {2,3} 3   100 {1} 4   101 {1,3} 5   110 {1,2} 6   111 {1,2,3} 7    代码的具体实现上，可以通过 1 \u0026laquo; nums.length 获取子集的总数；可以利用性质 9 取出相应二进制位上的数值用以构建子集的具体结构。具体的代码实现如下：\n/** * @param {number[]} nums * @return {number[][]} */ var subsets = function(nums) { var res = [], len = nums.length for (var i = 0; i \u0026lt; (1 \u0026lt;\u0026lt; len); i++) { var currSubset = [] for (var j = 0; j \u0026lt;= len; j++) { if (i \u0026amp; (1 \u0026lt;\u0026lt; j)) currSubset.push(nums[j]) } res.push(currSubset) } return res }; 复杂度分析：\n时间复杂度为 $O(n2^n))$，子集的总数为 1 \u0026laquo; n 即 $2^n$ 种，得 $O(2^n)$，构造每个子集时需要遍历一次原数组，得 $O(n)$。\n空间复杂度为 $O(n)$，只有构造子集时使用的临时数组需要额外空间的开销。\n136 - 只出现一次的数字 https://leetcode-cn.com/problems/single-number\n给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。\n说明：\n你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？\n示例 1:\n输入: [2,2,1]\n输出: 1\n示例 2:\n输入: [4,1,2,1,2]\n输出: 4\n从位运算出发去思考，我们可以找到性质 1、2，两个相等的数异或之后为 0，一个数异或 0 等于它本身，那么将数组中所有元素相异或之后，出现 2 次的数字就会全部被约去，剩下只出现 1 次的数字，代码如下：\n/** * @param {number[]} nums * @return {number} */ var singleNumber = function(nums) { var res = 0 for (var i = 0; i \u0026lt; nums.length; i++) { res ^= nums[i] } return res }; 复杂度分析：\n时间复杂度为 $O(n)$，因为只有一次遍历数组操作。\n空间复杂度为 $O(1)$，没有额外空间开销。\n169 - 多数元素 https://leetcode-cn.com/problems/majority-element\n给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数大于⌊ n/2 ⌋ 的元素。\n你可以假设数组是非空的，并且给定的数组总是存在多数元素。\n示例 1：\n输入： [3,2,3]\n输出： 3\n示例 2：\n输入： [2,2,1,1,1,2,2]\n输出： 2\n题干要求的多数元素，出现次数大于 n/2，从位运算出发去思考可以推断，如果将每一个数字都用 32 位二进制序列列出，去统计每一个二进制位是 0 多还是 1 多，则由每一位的多数元素组成的二进制序列，就可以组成最终那个多数元素的数值。代码如下：\n/** * @param {number[]} nums * @return {number} */ var majorityElement = function(nums) { var res = 0, len = nums.length for (var i = 0; i \u0026lt; 32; i++) { var ones = 0, zero = 0 for (var j = 0; j \u0026lt; len; j++) { if (ones \u0026gt; len / 2 || zero \u0026gt; len / 2) { break } if ((nums[j] \u0026amp; (1 \u0026lt;\u0026lt; i)) === 0) { zero++ } else { ones++ } } if (ones \u0026gt; zero) res |= 1 \u0026lt;\u0026lt; i } return res }; 复杂度分析：\n时间复杂度为 $O(n)$，一次枚举二进制序列上所有的位（32 位），一次遍历整个数组。\n空间复杂度为 $O(1)$，没有额外空间开销。\n342 - 4 的幂 https://leetcode-cn.com/problems/power-of-four\n给定一个整数，写一个函数来判断它是否是 4 的幂次方。如果是，返回 true；否则，返回 false。整数 n 是 4 的幂次方需满足：存在整数 x 使得 n == 4 ^ x。\n示例 1：\n输入： n = 16\n输出： true\n示例 2：\n输入： n = 5\n输出： false\n示例 3：\n输入： n = 1\n输出： true\n将 32 个二进制位铺开来看，一个数为 4 的幂意味着有唯一的数字 1 在序列的奇数位置出现。\n0000 0000 0000 0000 0000 0000 0000 0001 # 1 0000 0000 0000 0000 0000 0000 0000 0100 # 4 0000 0000 0000 0000 0000 0000 0001 0000 # 16 0000 0000 0000 0000 0000 0000 0100 0000 # 64 所以可以利用性质 11，根据消去最后一个 1 之后结果是否为 0，可以判断数字的二进制序列中是否存在唯一的 1；另外在循环中使用 \u0026raquo;\u0026gt; 右移操作符直到数字为 0，可以统计出 1 的初始位置。因此代码如下：\n/** * @param {number} n * @return {boolean} */ var isPowerOfFour = function(n) { // 是否唯一的 1  var onlyOne = (n \u0026amp; (n - 1)) === 0 // 求 1 的位置  var pos = 0, temp = n while (temp !== 0) { temp \u0026gt;\u0026gt;\u0026gt;= 1 pos++ } // 若有唯一的 1，且 1 是奇数，则认为其是 4 的幂  return onlyOne \u0026amp;\u0026amp; ((pos \u0026amp; 1) !== 0) }; 复杂度分析：\n时间复杂度为 $O(1)$，解中唯一的循环，是在二进制序列上移动，移动到数字本身为 0，即可求出唯一 1 原来的位置。\n空间复杂度为 $O(1)$，没有额外空间开销。\n461 - 汉明距离 https://leetcode-cn.com/problems/hamming-distance\n两个整数之间的汉明距离指的是这两个数字对应二进制位不同的位置的数目。\n给出两个整数 x 和 y，计算它们之间的汉明距离。\n注意： 0 ≤ x, y \u0026lt; 231.\n示例:\n输入: x = 1, y = 4\n输出: 2\n上面的箭头指出了对应二进制位不同的位置。\n首先列出示例中两个数的二进制序列：\n0000 0000 0000 0000 0000 0000 0000 0001 0000 0000 0000 0000 0000 0000 0000 0100 很明显，只要把两数相异或，二进制位不同的位在结果中即为 1，再使用性质 11 统计结果中 1 的个数，即可得解。因此代码如下：\n/** * @param {number} x * @param {number} y * @return {number} */ var hammingDistance = function(x, y) { var xorRes = x ^ y, count = 0 while (xorRes !== 0) { xorRes \u0026amp;= (xorRes - 1) count++ } return count }; 时间复杂度与空间复杂度均为 $O(1)$。\n1356 - 根据数字二进制下 1 的数目排序 https://leetcode-cn.com/problems/sort-integers-by-the-number-of-1-bits\n给你一个整数数组 arr 。请你将数组中的元素按照其二进制表示中数字 1 的数目升序排序。\n如果存在多个数字二进制中 1 的数目相同，则必须将它们按照数值大小升序排列。\n请你返回排序后的数组。\n示例 1：\n输入： arr = [0,1,2,3,4,5,6,7,8]\n输出： [0,1,2,4,8,3,5,6,7]\n解释： [0] 是唯一一个有 0 个 1 的数。\n[1,2,4,8] 都有 1 个 1。\n[3,5,6] 有 2 个 1。\n[7] 有 3 个 1 。\n按照 1 的个数排序得到的结果数组为 [0,1,2,4,8,3,5,6,7]\n最暴力的方法，直接调用语言自带的排序函数，对比函数中则使用性质 11 统计 value1 和 value2 二进制序列中 1 的个数，最终 1 的个数不同时按照 1 的个数升序，相同时按照数值大小升序。因此代码如下：\n/** * @param {number[]} arr * @return {number[]} */ var sortByBits = function(arr) { return arr.sort((v1, v2) =\u0026gt; { var temp1 = v1, temp2 = v2, count1 = 0, count2 = 0 while (temp1 !== 0) { temp1 \u0026amp;= temp1 - 1 count1++ } while (temp2 !== 0) { temp2 \u0026amp;= temp2 - 1 count2++ } return count1 === count2 ? v1 - v2 : count1 - count2 }) }; 复杂度分析：\n开销全部来自于系统自带的排序函数，JS 的 Array.prototype.sort 是使用快排实现的，因此复杂度与快排一致，时间复杂度为 $O(nlogn)$，空间复杂度为 $O(n)$。\n总结 在上面列出的题目中，我认为 78 - 子集 和 169 - 多数元素 是很有代表性的题目，这类问题的共通性在于，题干都可以拆分为多个是非问题的组合。78 - 子集 是被拆分为了数组中的每一个数是否存在的问题的集合；而 169 - 多数元素 则是被拆分为统计二进制序列中每一个位置上的多数值。因此在解题时可以从这个方向进行思考。\n位掩码 虽然本篇是从算法角度切入，但是位运算在日常开发中还有一些实用的小技巧，比如知名 JS 函数库 Lodash 中使用到的位掩码技术。\n位掩码通常用于处理多个布尔变量的组合，在 Lodash 中，JS 对象拷贝相关函数的基础函数 baseClone 就使用了位掩码来控制不同的克隆方式。让我们直接来解读一下它的核心代码。\n首先，我们需要几个预设的掩码，它们都是由一个仅有唯一 1 的二进制序列组成的（因此它们都是 2 的幂），每个二进制位代表一个开关，而后续的代码中，则可以通过某些二进制运算，来表示各种关系的不同组合：\nconst CLONE_DEEP_FLAG = 1 // 0001：深拷贝 const CLONE_FLAT_FLAG = 2 // 0010：拷贝原型链标志位 const CLONE_SYMBOLS_FLAG = 4 // 0100：拷贝 Symbol 类型标志位 然后是 cloneDeep 的代码，它调用了 baseClone，并传入了掩码 CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG，这个表达式运算的结果是 5，也就是二进制的 0101。我们发现，通过 | 运算将两个掩码组合，就可以让两个标志位同时变成 1：\nfunction cloneDeep(value) { // cloneDeep 需要深克隆和克隆 Symbol  // 1 | 4 -\u0026gt; 0001 | 0100 -\u0026gt; 0101  return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG) } 最后找到了 baseClone 的核心代码，这里将刚才传入的 CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG 和三个掩码分别进行 \u0026amp; 操作，突然发现这里正是用到了常用性质中的性质 3！这时会发现，我们只要将传入的掩码 bitmask 与各个标志的掩码进行 \u0026amp; 操作，则如果 bitmask 中相应的二进制位为 1，则结果就是该掩码的值；如果 bitmask 中相应的二进制位为 0，则结果就是 0。这样就可以为每个标志位生成其对应的布尔变量，用于后续的函数判断了：\n// 刚才我们传入的值是 1 | 4 = 5 // 因此 isDeep 的值即为 5 \u0026amp; 1 = 1 // 0101 // \u0026amp; 0001 // ------ // 0001 // 可以发现，当传入掩码的二进制序列中存在相应标志位时 // \u0026amp; 操作就会直接返回当前标志位的掩码 // 这样，如果返回的结果为 0，则意味着掩码中不存在相应标志位，结果为 0 == false // 如果返回的结果大于 0，则意味着掩码中存在相应标志位，结果为任意数字，转换为布尔值为 true function baseClone(value, bitmask, customizer, key, object, stack) { const isDeep = bitmask \u0026amp; CLONE_DEEP_FLAG const isFlat = bitmask \u0026amp; CLONE_FLAT_FLAG const isFull = bitmask \u0026amp; CLONE_SYMBOLS_FLAG ... } References\n位运算有什么奇技淫巧？ - 伍亦勤的回答 - 知乎\n位运算符 - MDN\n【进阶4-4期】Lodash是如何实现深拷贝的 - 木易杨\n","permalink":"https://geekhouse.top/posts/algorithm_bit/","tags":["Algorithm"],"title":"位运算的算法应用"},{"categories":null,"contents":"前言 手上的公司项目热重载一直很慢，每次热重载大概要 15s 左右，最近实在忍无可忍，决定排查一下。\n猜想 项目是基于 vue-cli2 搭建的，前人将 webpack 升级到了 webpack4。出于历史原因，公司项目的模块是根据模板（.html）划分的，因此项目中存在超过 30 个模板。这让我想起了之前在优化一个 webpack3 项目的时候，也遇到过类似的多模板热重载缓慢的情况，当时是使用 html-webpack-plugin-for-multihtml 库 解决了问题，因此我想，这次会不会也是 html-webpack-plugin 的锅呢？\n升级 html-webpack-plugin 问题解决 我尝试把 html-webpack-plugin 升级到了最新的 @4.0.0-beta.8 版本，发现热重载速度降到了 1s 左右！\n问题解决了，可是其中的原理是什么呢？\n使用 cpuprofile-webpack-plugin 进行性能分析 cpuprofile-webpack-plugin 是一个图形化的 webpack 构建性能分析工具，它会统计构建过程中每个插件运行的时间，还会生成整个构建过程的火焰图，如下图，它记录了我的项目使用 html-webpack-plugin@3.2.0 时一次热重载的性能分析：\n 图：cpuprofile-webpack-plugin 分析结果\n 我们发现在整个 15.94s 的热重载过程中，html-webpack-plugin 的运行时间占据了 13.51s，可以说几乎全部时间都用在了这上面，这个图也验证了我的猜想。接下来，我们通过火焰图进一步分析，首先找一个运行时间较长，比较有代表性的 html-webpack-plugin 执行过程：\n 图：一次时间较长的 html-webpack-plugin 运行\n 点击进去，查看更详细的调用栈分析：\n 图：html-webpack-plugin 详细的调用栈分析\n 发现全部耗时集中在 html-webpack-plugin/index.js -\u0026gt; templateParametersGenerator -\u0026gt; toJson 函数上。\n查看源码 首先查看了最新版（4.0.0-beta.8）中 templateParametersGenerator 方法的源码，可以看出它是用来生成 templateParameters 的默认配置的，而在这个版本中它并没有调用 toJson 方法：\n 图：4.0.0-beta.8 templateParametersGenerator 的调用\n  图：4.0.0-beta.8 templateParametersGenerator 的定义\n 然后回溯 3.2.0 版本之前的提交，终于见到了它的调用，webpack 文档中解释 compilation.getStats().toJson() 是用来生成编译过程的性能分析 json 文件的方法，那么罪魁祸首就是它了。\n 图：3.2.0 templateParametersGenerator 的定义\n 查找修复这个问题的 commit 后来我尝试了把 html-webpack-plugin 的版本回退到 4.x 的第一个版本 4.0.0-alpha，发现热重载性能依然是没问题的，因此提交的定位就在 3.2.0 到 4.0.0-alpha 之间，经过一番查找，终于找到了这个 fix，出于性能原因移除 compilation.getStats()：\n 图：fix: Remove compilation.getStats() call for performance reasons\n 后记 其实这次排查我也走了不少弯路，之前一直在尝试通过阅读代码查找，找了一天都找不出来，后来使用了性能分析工具才知道自己之前有多蠢 :-)。本文只是给大家讲一个性能分析的故事，为大家提供一些思路，希望大家的代码都没有bug~\n附：html-webpack-plugin 4.x 钩子函数的变更 由于我的代码里踩了这个坑，所以给大家讲一下，html-webpack-plugin 4.x 对钩子函数进行了重构，注意是重构，不是更新，也就是说，虽然名字改了，但是所有功能都是没有变化且一一对应的，作者的 commit 里使用的 badge 也是 refactor：\n 图：钩子函数重构的 commit\n  图：3.x 钩子函数文档\n  图：4.x 钩子函数文档\n  图：4.x 钩子函数文档\n ","permalink":"https://geekhouse.top/posts/engineering_html-webpack-plugin_4.x_change/","tags":["Engineering"],"title":"html-webpack-plugin 4.x 对多模板下热重载缓慢问题的修复"},{"categories":null,"contents":"前言 作为一个非计算机专业出身的渣渣小前端，算法是前端技能进阶路上一座绕不开的大山。曾经尝试到 leetcode 上开坑，然而发现做出一道题，要花上好几个小时的时间。后来搜了一些算法学习方法相关的文章，许多人都提到：算法需要先系统性的学习，再去做题。而我平时开发最常使用 JavaScript，因此选用《数据结构与算法 JavaScript 描述》一书作为入门书籍。\n阅读这本书之后，我与 《JS家的排序算法》 作者有一个相同的感受：书里有很多小错误，不仅仅是在文字描述上，在代码中也有出现。但是不得不承认，这本书非常适合前端开发者的算法入门学习，原因是其内容足够简洁、基础，它简洁明了地解释了每种算法的原理，没有涉及优化，以及算法考察中的一些难点。所以，如果需要进阶学习，还是需要配合其他书籍食用。\n这篇文章权当我学习算法过程中的笔记，就从算法中基础的类别：排序算法开始，有问题请大家指出，我会尽快修正，避免误导他人。\n首先搭建一个简单的性能测试平台：\n// 使用一个函数集合保存所有用于测试的排序算法 let funcs = { // 工具：交换数组元素  toolExch (a, lo, hi) { let temp = a[lo]; a[lo] = a[hi]; a[hi] = temp } } // 生成一个长度为 10000，数值为 0-99 之间的数组用于测试 // 注意：排序算法的性能往往与被排序数组的特性有关系 // 如重复数据的数量、数据大小的分布、数据整体的方差等 // 本文主要的方向还是说明各种排序算法的原理 // 因此直接生成一组随机数作为测试数据 let arr = Array.from({ length: 10000 }, v =\u0026gt; Math.floor(Math.random() * 100)) // 执行集合中所有函数 for (let key in funcs) { // 遇到有 tool 标记的函数判断为工具函数，跳过  if (!key.indexOf(\u0026#39;tool\u0026#39;)) { continue } let temp = Array.from(arr) // 使用 console 中的 time 和 timeEnd 函数输出代码执行时间  console.time(key) funcs[key](temp) console.timeEnd(key) } 冒泡排序 冒泡排序是最慢的排序算法之一，因为它交换元素的次数实在是太多了，但它也是最容易实现的排序算法。在运行过程中，数据值会像气泡一样从一端漂浮到另一端，比如升序排序，数据会与其右侧相邻的数据进行比较，若它比右侧数据大，则会向右边“冒泡”，直到遇到比它大的数据为止。\n动图演示  Bubble Sort 动图演示 算法可视化来源：http://visualgo.net/\n 代码实现 let funcs = { // 冒泡排序  bubbleSort (arr) { // 使用一个两层的循环执行排序  // 内层循环每执行一次，外层循环的指针 i 就向前进一步，表示前面的数据确认已经完成排序  for (let i = 0; i \u0026lt; arr.length - 1; i++) { // 内层循环保证每次都能将最小的数据移到数组最左边  for (let j = arr.length - 1; j \u0026gt; i; j--) { // 当前数据值比前一位的小，则将两个数据交换位置  // 否则不进行操作，继续处理下一位的数据  if (arr[j] \u0026lt; arr[j - 1]) { this.toolExch(arr, j - 1, j) } } } return arr } } 选择排序 选择排序的原理，以升序排序为例，就是从数组的开头开始，用第一条数据和其他数据进行比较，取其中最小的数据，与第一个位置的数据交换，再用第二条数据对后面的数据进行比较\u0026hellip;\u0026hellip;如此反复，当在数组的倒数第二位上执行完这个比较，整个排序就完成了。\n与冒泡排序一样，选择排序也采用了两层循环，但选择排序在每次遍历中只进行了一次数据位置的交换，因此它的速度比冒泡排序要快的多。\n动图演示  Selection Sort 动图演示 算法可视化来源：http://visualgo.net/\n 代码实现 let funcs = { // 选择排序  selectionSort (arr) { // 外层循环维护一个指针 i，每当内层循环完成一次交换，外层循环的指针就往前移一步  // 指针移动到倒数第二个位置 arr.length - 2 时，结束循环  for (let i = 0; i \u0026lt;= arr.length - 2; i++) { // index 维护了当前内循环中最小值的位置  let index = i // 内层循环从指针 i 的位置往后查找最小的数据  for (let j = i; j \u0026lt; arr.length; j++) { // 每当找到更小的数据，就更新 index  if (arr[j] \u0026lt; arr[index]) index = j } // 将位置在 index 的最小数据与位置在 i 的当前指针互换位置  this.toolExch(arr, index, i) } return arr } } 性能比较 用上面的代码进行一次粗略的运行（10000 条数据），得出选择排序的性能要远远超过冒泡排序。\n插入排序 插入排序同样使用两层循环，以升序排序为例：外层循环维护了一个指针 i，它从第二条数据开始向右移动。内层循环则维护一个指针 j 从 i 的位置开始向左移动，若 j 左边的数据比 j 大，则将左边的数据右移一格，直到遇到 j 左边的数据比 j 小，就停止移动，并把最开始用于比较的 i 上的数据插入到这一位置。如此反复，可以保证每次内循环结束，i 左边的数据都是有序的，则执行完外循环即可完成排序。\n动图演示  Insertion Sort 动图演示 算法可视化来源：http://visualgo.net/\n 代码实现 let funcs = { // 插入排序  insertionSort (arr) { // 向右移动的外循环  for (let i = 1; i \u0026lt; arr.length; i++) { // 声明内循环指针  let j = i // 记录用于比较的当前数据  let curr = arr[i] // 内循环，让当前数据一直向左移动  // 直到遇到比当前数据小的值，或移动到数组左端为止  while (j \u0026gt; 0 \u0026amp;\u0026amp; arr[j - 1] \u0026gt; curr) { // 将更大的数据往右推  arr[j] = arr[j - 1] // 指针左移  j-- } // 将当前数据插入到正确位置，使得 0~i 之间的数据有序  arr[j] = curr } return arr } } 性能比较  图片来自 algs4.cs.princeton.edu\n 根据《算法（第4版）》中比较插入排序与选择排序的可视轨迹图，发现插入排序加入比较的数据比选择排序要少许多。因此，插入排序的性能是要强于选择排序的。\n用上面的代码进行一次粗略的运行（10000 条数据），发现插入排序比选择排序快许多。\n希尔排序 《数据结构与算法 JavaScript 描述》一书中将希尔排序放在了高级算法的开篇位置，其实，希尔排序是在插入排序的基础上进行了改善，它定义了一个间隔序列，让算法先比较大间隔的数据，使离正确位置远的元素可以更快的归位，从而减少比较的次数，然后缩小间隔序列进行比较，直到间隔序列为 1 时，数组有序。\n《算法（第4版）》的合著者 Robert Sedgewick 通过一个公式动态定义了希尔排序中的间隔序列，在我们的代码实现中，就采用这种方法定义间隔序列。原书中将这种方式称为“简洁的希尔排序”，事实上，希尔排序的性能与间隔序列的定义有着密切的联系。\n 对间隔为 4 的数据进行比较示意图\n 动图演示  希尔排序动图演示\n 代码实现 let funcs = { // 希尔排序  shellSort (arr) { // 定义间隔序列 gap  let len = arr.length let gap = 1 while (gap \u0026lt; len / 3) { gap = gap * 3 + 1 } // 按照间隔序列中的间隔逐次进行插入排序  while (gap \u0026gt;= 1) { // 执行插入排序  for (let i = gap; i \u0026lt; len; i++) { let j = i let curr = arr[i] while (j \u0026gt;= gap \u0026amp;\u0026amp; arr[j - gap] \u0026gt; curr) { arr[j] = arr[j - gap] // 每次前进的步数为 gap，形成对间隔的使用  j -= gap } arr[j] = curr } // 生成下一个间隔  gap = (gap - 1) / 3 } return arr } } 性能比较 希尔排序的效率与间隔序列的选择有很大的关系，《算法（第4版）》中描述道：“算法的性能不仅取决于 h（即间隔），还取决于 h 之间的数学性质，比如他们的公因子等。有很多论文研究了各种不同的递增序列，但都无法证明某个序列是‘最好的’”。\n用上面的代码对 10000 条数据运行，发现在这个体量下希尔排序比插入排序快非常多。\n归并排序 归并排序是应用高效算法设计中分治思想的典型栗子，它的基本原理就是将数组不断的对半拆分，直到拆分为一对单个元素，然后将一对单个元素排列至有序，再与相邻的一对有序元素合并为一个大的有序数组，直到整个数组有序。\n在代码上，它有两种实现方式，分别是使用递归的，自顶向下的归并排序（请见动图演示：自顶向下的归并排序），以及使用循环的，自底向上的归并排序（请见图片演示：自底向上的归并排序）。它们各有各的优点，递归方式比较容易实现，但是会占用额外的内存空间；循环方式逻辑比较复杂，但是占用内存较少，性能较好。\n《JS家的排序算法》 一文中指出：\n 好消息！好消息！ES6已经添加了对尾递归优化的支持，妈妈再也不用担心我用JavaScript写递归了。不过，需要注意的是，ES6的尾递归优化只在严格模式下才会开启。\n 事实上，在浏览器端，除了 Safari，各大浏览器都并没有实现尾递归优化的特性。在 node 中，尾递归优化也并不是默认开启的，需要在调用时使用--harmony_tailcalls参数，才能手动开启。而且 JS 的尾递归优化仍存在隐式优化和调用栈丢失的问题。因此，在 JS 引擎下使用递归方式的归并排序，仍然有性能和稳定性方面的担忧。详情参考 《尾递归的后续探究》。\n动图演示  动图演示：自顶向下的归并排序 算法可视化来源：http://visualgo.net/\n  图片演示：自底向上的归并排序\n 代码实现 let funcs = { // 自顶向下的归并排序  merge (arr) { // 递归的排序方法，接收数组、要排序的起始位置与结束位置  let sort = (a, lo, hi) =\u0026gt; { // 若 hi \u0026lt;= lo，则数组已经无法再分半，即为递归终点，则开始进行排序  if (hi \u0026lt;= lo) return // 计算要排序数组的中间位置  // mid 即为前半部分排序的终点  // mid + 1 为后半部分排序的起点  let mid = lo + Math.floor((hi - lo) / 2) // 分别对前后两半进行递归调用，直到无法再分半为止  sort(a, lo, mid) sort(a, mid + 1, hi) // 对数组前后两半执行归并  this.toolMerge(a, lo, mid, hi) } sort(arr, 0, arr.length - 1) return arr }, // 自底向上的归并排序  mergeBU (arr) { // 获取数组长度  let len = arr.length // 外层循环维护一个归并的单位大小 sz  // 因为总是进行对半拆分，所以它每次进行归并的数组应该扩大为 2 倍，即每次递增操作为 sz *= 2  for (let sz = 1; sz \u0026lt; len; sz *= 2) { // 内循环维护了每次归并的数组的起始位置 lo  // 结束条件的解释是：lo + sz 指进行归并数组的前一半长度，若 lo + sz 的右边已经没有数据可供归并，则循环可以结束  // 内循环每次执行归并的数组大小为 sz * 2，因此每次递增增加 sz * 2  for (let lo = 0; lo \u0026lt; len - sz; lo += sz * 2) { // 对当前操作的数组执行归并  // 起始点为 lo，中间位置为 lo + sz - 1  // 结束位置若数组末端的下标更小，则需取数组末端的位置，以结束整个数组的归并  this.toolMerge(arr, lo, lo + sz - 1, Math.min(lo + sz * 2 - 1, len - 1)) } } return arr }, // 工具函数：原地归并  // 它接收一个两半各自有序的数组、起始位置、中间位置、结束位置四个参数  // 输出将数组左右两半归并（边合并边排序），得出的大的有序数组  toolMerge (a, lo, mid, hi) { // 声明指针 i、j，用于表示分别遍历左右两半数组的下标  let i = lo // 左数组的开头  let j = mid + 1 // 右数组的开头  // 声明一个临时数组，并将传入数组的所有元素复制过去  // 再从临时数组中取出元素回归到原数组中，最终输出原数组  let temp = [] for (let k = lo; k \u0026lt;= hi; k++) temp[k] = a[k] // 遍历临时数组  for (let k = lo; k \u0026lt;= hi; k++) { // 若左数组已经取完，则必从右数组取值，并将右数组指针右移一步  if (i \u0026gt; mid) { a[k] = temp[j++] } // 若右数组已经取完，则必从左数组取值，并将左数组指针右移一步  else if (j \u0026gt; hi) { a[k] = temp[i++] } // 若此时右数组的值更小，则取右数组的值回归原数组，并将右数组指针右移一步  else if (temp[i] \u0026gt;= temp[j]) { a[k] = temp[j++] } // 若此时左数组的值更小，则取左数组的值回归原数组，并将左数组指针右移一步  else if (temp[i] \u0026lt; temp[j]) { a[k] = temp[i++] } } } } 性能比较 用上面的代码对 10000 条数据运行，发现这里的归并排序比希尔排序还要慢一些，但还是比选择排序和插入排序等基础排序快。\n《算法（第4版）》中描述道：“在实际应用中，归并排序与希尔排序的运行时间差距在常数级别之内，因此相对性能取决于具体的实现。理论上来说，还没有人能证明希尔排序对于随机数据的运行时间是线性对数级别的，因此存在平均情况下希尔排序的运行时间更高的可能性。在最坏情况下，这种差距的存在已经被证实，但这对实际应用没有影响。”\n事实上，归并排序还能通过对小规模数组执行插入排序、当左数组的最右小于右数组的最左时直接认定整个数组有序等方式优化其性能。所以，上面的代码是有很大的优化空间的，也并不能说明归并排序比希尔排序慢。\n快速排序 许多书籍都给予了快速排序很高的评价。快速排序是一种平均性能十分优秀的算法，且只需要一个很小的辅助栈（占用内存小），原理也十分简单。\n快速排序同样是基于分治的设计思想，它需要一个切分点 pivot，以升序排序为例，将数组剩余的元素中大于 pivot 的放到它的右边，小于 pivot 的放到它的左边，然后对根据 pivot 切分的左数组和右数组再分别进行同样的排序，然后递归进行切分操作，直到整个数组有序。\n动图演示  Quick Sort 动图演示 算法可视化来源：http://visualgo.net/\n 代码实现 let funcs = { // 使用辅助数组进行拆分，实现非常简单  qSort (arr) { if (arr.length === 0) { return [] } // 声明辅助数组，保存比 pivot 小及比 pivot 大的数据  // 声明 pivot，这里为了方便直接取数组的第一个值  // 事实上，pivot 可以为被排序数组中任意的值，且如何对它进行取值会影响算法最终的性能  let lesser = [], greater = [], pivot = arr[0] // 遍历数组，将小于 pivot 的数据放入 lesser中  // 大于 pivot 的数据放入 greater 中  for (let i = 1; i \u0026lt; arr.length; i++) { if (arr[i] \u0026lt; pivot) { lesser.push(arr[i]) } else { greater.push(arr[i]) } } // 最终输出 [...小于 pivot 的数据集合, pivot, ...大于 pivot 的数据集合]  // 并对被切分后的左右数组分别进行递归调用，以输出有序的左右数组  // 因此在所有递归完成后，整个数组就会有序  return this.qSort(lesser).concat(pivot, this.qSort(greater)) } } 性能比较 上面的代码大量运用了 JS 的原生 API，性能必然不会出彩，下面我们来看看它的性能表现。\n用上面的代码对 10000 条数据运行，结果快速排序的性能只比上述未经性能优化的归并排序好一些，与身为基础排序的插入排序性能几乎持平，远远逊色于之前实现的希尔排序。\n将数据量扩大到 100000 条，发现这里实现的快速排序的性能更差，运行时间是上面归并排序的两倍。但是很有意思的是，当数据量增大，基础排序算法的性能出现急剧下降，基于分治思想的归并排序与快速排序则展现出了优势。\n《算法（第4版）》中对于快速排序的优缺点进行了明确的解释：“快速排序的内循环比大多数排序算法都要短小，这意味着它无论是在理论上还是在实际中都要更快。它的主要缺点是非常脆弱，在实现时要非常小心才能避免低劣的性能。”因此快速排序需要各种算法优化的手段，避免这些情况的发生。\n快速排序的优化 使用交换前后数组元素的方式切分，减少操作的次数 根据上一节实现的经验，我们应该避免在切分的过程中使用 JS 的原生 API，因此我们需要优化切分的过程，这里采用交换前后数组的方式进行切分。\n图片演示 代码实现 let funcs = { // 使用交换前后数组元素的方式切分  qSortOptimizeSegmentation (arr) { // 接收数组 a、数组起始位置 lo、结束位置 hi  // 将数组切分为左边小于切分点，右边大于切分点的两部分  // 最终输出切分点的位置  let partition = (a, lo, hi) =\u0026gt; { // 声明指针 i、j，分别从前向后以及从后向前遍历数组；声明切分点 v  let i = lo, j = hi + 1, v = a[lo] // 外循环控制 i、j 两枚指针的运动情况，当他们相遇则结束循环  while (true) { // 内循环遍历输入的数组，i 从前往后移动，j 从后往前移动  // 只要获取到大于等于 v 的值，i 循环结束，获取需要移动到切分点右侧的数据位置 i  // j 循环同理  while (a[++i] \u0026lt; v) { if (i === hi) { break } } while (a[--j] \u0026gt; v) { if (j === lo) { break } } // 外循环终止条件，两枚指针相遇，整个数组遍历完成  if (i \u0026gt;= j) { break } // 将需要移动到另一侧的两个数据交换位置  this.toolExch(a, i, j) } // 此时数据已经以 j 与 j + 1 之间为分界，切分为了比 v 小的左数组与比 a 大的右数组  // 将切分点与 j 数据交换位置，得出切分后的数据  this.toolExch(a, lo, j) // 输出切分点位置 j  return j } let qs = (a, lo, hi) =\u0026gt; { // 处理到数组末尾，结束递归  if (lo \u0026gt;= hi) { return } // 将数组切分为左边小于切分点，右边大于切分点的两部分，并输出切分点位置 j  let j = partition(a, lo, hi) // 对左数组与右数组递归执行排序  qs(a, lo, j - 1) qs(a, j + 1, hi) } qs(arr, 0, arr.length - 1) return arr } } 性能比较 10000 条数据的测试，可以发现将切分方式优化之后，速度明显加快。\n将测试数据增加到 100000 条，发现优化切分方式后的快速排序性能已经超越了之前的所有实现。也可以发现，对于越大的数据集，越能发挥快速排序的性能优势。\n对小数据集进行插入排序，优化小数据集的排序速度 《算法（第4版）》中说明了在小数据集中使用插入排序的原因：\n和大多数递归排序算法一样，改进快速排序性能的一个简单办法基于以下两点：\n 对于小数组，快速排序比插入排序慢 因为递归，快速排序的 sort() 方法在小数组中也会调用自己  因此，在排序小数组时应该切换到插入排序。然而，多小的数组才需要切换到插入排序呢？书中解释道：转换参数的最佳值是和系统相关的，但是 5~15 之间的任意值在大多数情况下都能令人满意。\n代码实现 let funcs = { // 对大小小于 10 (5-15均可) 的数据集进行插入排序，优化小数据集的排序速度  qSortOptimizeSmallDataSet (arr) { let partition = (a, lo, hi) =\u0026gt; { let i = lo, j = hi + 1, v = a[lo] while (true) { while (a[++i] \u0026lt; v) { if (i === hi) { break } } while (a[--j] \u0026gt; v) { if (j === lo) { break } } if (i \u0026gt;= j) { break } this.toolExch(a, i, j) } this.toolExch(a, lo, j) return j } let qs = (a, lo, hi) =\u0026gt; { // 起止位置的距离小于等于 10 时采用插入排序并结束递归  if (hi \u0026lt;= lo + 10) { a = this.toolInsertionSort(a, lo, hi); return } let j = partition(a, lo, hi) qs(a, lo, j - 1) qs(a, j + 1, hi) } qs(arr, 0, arr.length - 1) return arr }, // 在指定范围内执行插入排序  // 在插入排序章节中的实现基础上增加起止位置的参数  toolInsertionSort (arr, lo, hi) { for (let i = lo; i \u0026lt; hi + 1; i++) { let j = i let curr = arr[i] while (j \u0026gt; lo \u0026amp;\u0026amp; arr[j - 1] \u0026gt; curr) { arr[j] = arr[j - 1] j-- } arr[j] = curr } return arr } } 性能比较  qSortOptimizeSmallDataSet 处理 10000 条数据\n  qSortOptimizeSmallDataSet 处理 100000 条数据\n  qSortOptimizeSmallDataSet 处理 1000000 条数据\n  qSortOptimizeSmallDataSet 处理 10000000 条数据\n 超过一百万条数据之后，优化了小数据集处理的 qSortOptimizeSmallDataSet 函数取得了更好的成绩。\n使用三向切分优化它在应对大量重复数据时的效率 三向切分的关注点在于应对大量的重复数据。标准的快速排序仍然是基于比较的，这意味着无论重复元素有多少，它都会对所有元素进行比较来输出结果。而三向切分的原理则是将重复的元素聚合到数组中间，小元素分布到重复元素序列的左边，而大元素则分布在右边。\n图片演示  三向切分的轨迹（每次迭代循环之后的数组内容）\n 代码实现 let funcs = { // 三向切分把等于切分点的数据都移到中间，避免了所有等于切分点的数据重复排序  qSortThreeWayPartition (arr) { // 接收一个数组、起始位置与结束位置  let qs = (a, lo, hi) =\u0026gt; { // 同样对小于等于 10 的数据集进行插入排序  if (hi \u0026lt;= lo + 10) { a = this.toolInsertionSort(a, lo, hi); return } // 维护两个指针 lt、gt  // [0, lt] 范围保存比切分值小的数据  // [gt, arr.length - 1] 范围保存比切分数据大的数据  // [lt, gt] 范围则是当次迭代中重复的切分值  let lt = lo, gt = hi // 维护一个从左到右移动的指针 i，用于遍历数组  let i = lo + 1 // 标记当前的切分值 v  let v = a[lo] // 从左向右遍历数组，直到移动到 gt 位置结束  // 原因是  while (i \u0026lt;= gt) { // 若当前值小于切分值，则将当前值与 lt 位置的切分值换位  // lt++，即 lt 右移，为左侧空间的“新人”让一个位置  // i++，遍历指针右移  if (a[i] \u0026lt; v) { this.toolExch(a, lt++, i++) } // 若当前值大于切分值，则将当前值与 gt 位置的未知值换位  // gt--，即 gt 左移，为右侧空间的“新人”让一个位置  // i 指针此时不需要前进，因为从 gt 换过来的值未知，需要对这个位置重新进行判断  else if (a[i] \u0026gt; v) { this.toolExch(a, i, gt--) } // 若当前值等于切分值，则不做处理，让它呆在 [lt, gt] 范围  // 这个位置处理完毕，i 指针前进  else { i++ } } // 对不等于切分值的数据递归执行排序  qs(a, lo, lt - 1) qs(a, gt + 1, hi) } qs(arr, 0, arr.length - 1) return arr } } 性能比较  三向切分快速排序性能比较（十万条数据）\n  三向切分快速排序性能比较（一百万条数据）\n  三向切分快速排序性能比较（一千万条数据）\n 可以看出，数据量越大，三向切分的优势就越明显，这是因为重复的数据变多了。由于数据是在 0~100 范围内随机生成的，那么如果扩大或缩小数据生成的范围从而减少或增加重复值的数量，基于归类重复值的三向切分性能是否会受到影响呢？\n 三向切分快速排序性能比较（一千万条数据、在 0~10 范围内生成数据）\n  三向切分快速排序性能比较（一千万条数据、在 0~100 范围内生成数据）\n  三向切分快速排序性能比较（一千万条数据、在 0~1000 范围内生成数据）\n  三向切分快速排序性能比较（一千万条数据、在 0~10000 范围内生成数据）\n 我们发现，当生成范围缩小到 0~10 时，三向切分的优势被进一步扩大，但当生成范围扩大时，三向切分的优势迅速缩小，当生成数据在 0~10000 范围内时，三向切分的性能就已经低于二切分的实现了。因此三向切分的方案还是适用于重复数据比较多的时候，如对性别进行排序等等。\n小结 事实上，仅在《算法（第4版）》一书的内容中，快速排序的优化思路就还有：切换到插入排序的时机选择、切分点的取样方式选择（如使用数组中位数）、二切分中使用哨兵代替边界检查、取样切分等等。时间所限，如此多的优化方案实在无法一一研究，更何况还有堆排序、计数排序、桶排序与基数排序这一系列排序算法，如果有机会我再一一补充上来。\nReferences\n《JS家的排序算法》\n《数据结构与算法 JavaScript 描述》\n《算法（第4版）》\n","permalink":"https://geekhouse.top/posts/algorithm_sort/","tags":["Algorithm"],"title":"排序算法"},{"categories":null,"contents":"最近半年在维护公司的一个管理后台项目，搭建之初的技术栈比较混乱，构建方案采用了Gulp中调用Webpack的方式，Gulp负责处理.html文件，Webpack负责加载.vue、.js等。而在这一套构建方案中，主要有这些问题：\n 没有实现JS压缩、CSS兼容等功能。 在开发模式下，保存代码，项目会进行完全的重新打包，持续构建速度不仅缓慢，还会产生缓存的现象（构建完成后刷新页面改动不生效）。 由于目前的方案没有使用http-proxy-middleware这样的请求代理模块，导致项目在本地开发时还要部署后端服务，对新接手的开发者不友好，而且经常由于沟通不及时产生测试环境与本地环境的代码同步问题。  因此，在熟悉这个项目之后，打算对其构建方案进行升级，主要为了解决上述的问题。\n1. 原有构建方案描述 原有构建速度  npm run build：打包约50s npm run dev：开启开发模式约50s，保存自动重新编译需约6s，编译完成后需要刷新才能看到效果，偶尔因缓存问题需要再次自动重新编译才能看到效果  原有构建结果  ./build/development：存放渲染后的js文件 ./build/html：存放渲染后的html文件 ./build/rev：保存各个入口文件hash值的json文件  打包代码解析 /** * 使用gulp-clean插件删除build目录下的文件 */ gulp.task(\u0026#39;clean\u0026#39;, function () { if (!stopClean) { return gulp.src(\u0026#39;build/\u0026#39; + directory, { read: false }).pipe(clean()) } }) /** * 使用webpack打包vue与js文件，在clean之后进行 */ gulp.task(\u0026#39;webpack\u0026#39;, [\u0026#39;clean\u0026#39;], function (callback) { deCompiler.run(function (err, stats) { if (err) throw new gutil.PluginError(\u0026#39;webpack\u0026#39;, err) gutil.log(\u0026#39;[webpack]\u0026#39;, stats.toString({})) callback() }) }) /** * 使用gulp-uglify插件对js文件进行丑化，在webpack之后进行 */ gulp.task(\u0026#39;minify\u0026#39;, [\u0026#39;webpack\u0026#39;], function () { if (environment) { return } else { return gulp.src(\u0026#39;build/\u0026#39; + directory + \u0026#39;/*.js\u0026#39;).pipe(uglify()) } }) /** * 使用gulp-rev插件为打包后的文件增加hash，在minify之后运行 * * gulp-rev会做什么： * 根据静态资源内容，生成md5签名，打包出来的文件名会加上md5签名，同时生成一个json用来保存文件名路径对应关系。 * 替换html里静态资源的路径为带有md5值的文件路径，这样html才能找到资源路径。 * 有些人可能会做：静态服务器配置静态资源的过期时间为永不过期。 * 达到什么效果： * 静态资源只需请求一次，永久缓存，不会发送协商请求304 * 版本更新只会更新修改的静态资源内容 * 不删除旧版本的静态资源，版本回滚的时候只需要更新html，同样不会增加http请求次数 */ gulp.task(\u0026#39;hashJS\u0026#39;, [\u0026#39;minify\u0026#39;], function () { var dest = gulp.src([\u0026#39;一串入口文件...\u0026#39;]) .pipe(rev()) // 设置文件的hash key  .pipe(gulp.dest(\u0026#39;build/\u0026#39; + directory)) // 将经过管道处理的文件写出到目录  .pipe(rev.manifest({})) // 生成映射hash key的json  .pipe(gulp.dest(\u0026#39;build/rev\u0026#39;)) // 将经过管道处理的文件写出到目录  !environment \u0026amp;\u0026amp; gulp.src([\u0026#39;一串入口文件...\u0026#39;]).pipe(clean()) return dest }) /** * 使用gulp-rev-replace插件为html中引用的js和css替换新的hash * 使用gulp-livereload插件在所有文件重新打包完成后局部更新页面 */ gulp.task(\u0026#39;revReplace\u0026#39;, [\u0026#39;hashJS\u0026#39;], function () { return gulp.src([\u0026#39;html/*.html\u0026#39;]) .pipe(revReplace({ ... })) // 给html中的js引用提供新的hash  .pipe(gulp.dest(\u0026#39;build/html\u0026#39;)) // 输出文件  .pipe(livereload()) // 局部更新页面 }) /** * 使用gulp.watch，当应用程序目录下有任何文件发生改变，则重新执行一遍打包命令 * gulp.watch：监视文件，并且可以在文件发生改动时候做一些事情。 */ gulp.task(\u0026#39;watch\u0026#39;, [\u0026#39;revReplace\u0026#39;], function () { stopClean = true livereload.listen() gulp.watch(\u0026#39;app/**/*\u0026#39;, [\u0026#39;clean\u0026#39;, \u0026#39;webpack\u0026#39;, \u0026#39;minify\u0026#39;, \u0026#39;hashJS\u0026#39;, \u0026#39;revReplace\u0026#39;]) }) /** * 输出dev和build的工作流 */ gulp.task(\u0026#39;default\u0026#39;, [\u0026#39;clean\u0026#39;, \u0026#39;webpack\u0026#39;, \u0026#39;minify\u0026#39;, \u0026#39;hashJS\u0026#39;, \u0026#39;revReplace\u0026#39;, \u0026#39;watch\u0026#39;]) // dev gulp.task(\u0026#39;build\u0026#39;, [\u0026#39;clean\u0026#39;, \u0026#39;webpack\u0026#39;, \u0026#39;minify\u0026#39;, \u0026#39;hashJS\u0026#39;, \u0026#39;revReplace\u0026#39;]) // build /** * webpack配置 */ var devCompiler = webpack({ entry: { ... // 一众入口文件  vendor: [\u0026#39;vue\u0026#39;, \u0026#39;vue-router\u0026#39;, \u0026#39;lodash\u0026#39;, \u0026#39;echarts\u0026#39;] // 公共模块  }, output: { path: ..., // 所有输出文件的目标路径  publicPath: ..., // 输出解析文件的目录  filename: ..., // 输出文件  chunkFilename: ... // 通过异步请求的文件  }, // 排除以下内容打包到 bundle，减小文件大小  external: { jquery: \u0026#39;jQuery\u0026#39;, dialog: \u0026#39;dialog\u0026#39; }, plugins: [ /** * 通过将公共模块拆出来，最终合成的文件能够在最开始的时候加载一次，便存到缓存中供后续使用。 * 这个带来页面速度上的提升，因为浏览器会迅速将公共的代码从缓存中取出来，而不是每次访问一个新页面时，再去加载一个更大的文件。 */ new webpack.optimize.CommonsChunkPlugin({ name: [\u0026#39;vendor\u0026#39;] }), /** * DefinePlugin 允许创建一个在编译时可以配置的全局常量。这可能会对开发模式和生产模式的构建允许不同的行为非常有用。 */ new webpack.DefinePlugin({ __VERSION__: new Date().getTime() }) ], resolve: { root: __dirname, extensions: [\u0026#39;\u0026#39;, \u0026#39;.js\u0026#39;, \u0026#39;.vue\u0026#39;, \u0026#39;.json\u0026#39;], // 解析组件的文件后缀白名单  alias: { ... } // 配置路径别名  }, module: { // 各个文件的loaders  loaders: [ { test: /\\.vue$/, loader: \u0026#39;vue-loader\u0026#39; }, { test: /\\.css$/, loader: \u0026#39;style-loader!css-loader\u0026#39; }, { test: /\\.jsx$/, loader: \u0026#39;babel-loader\u0026#39;, include: [path.join(__dirname, \u0026#39;app\u0026#39;)], exclude: /core/ }, { test: /\\.json$/, loader: \u0026#39;json\u0026#39; } ] }, vue: { loaders: { js: \u0026#39;babel-loader\u0026#39; } } }) 2. 将Gulp的功能移到Webpack1上执行 使用html-webpack-plugin插件构建项目的主.html文件 module.exports = { plugins: [ new HtmlWebpackPlugin({ filename: \u0026#39;...\u0026#39;, // 输出的路径  template: \u0026#39;...\u0026#39;, // 提取源html的路径  chunks: [\u0026#39;...\u0026#39;], // 需要导入的模块  inject: true // 是否附加到body底部  }) ] } 使用webpack.optimize.UglifyJsPlugin插件进行JS压缩 module.exports = { plugins: [ new webpack.optimize.UglifyJsPlugin({ compress: { warnings: false } }) ] } 使用webpack-dev-server模块，提供node搭建的开发环境 module.exports = { devServer: { clientLogLevel: \u0026#39;warning\u0026#39;, // 输出日志的级别，配置为警告级别以上才输出  inline: true, // 启动 live reload  hot: true, // 允许启用热重载  compress: true, // 对所有静态资源进行gzip压缩  open: true, // 默认在启动本地服务时打开浏览器  quiet: true, // 禁止输出繁杂的构建日志  host: ..., // 服务启动的域名  port: ..., // 服务启动的端口  proxy: { ... }, // http代理配置  /** * 这个配置常用于解决spa应用h5路由模式下将所有404路由匹配回index.html的问题 * 由于生产环境为主页匹配了一个比较简单的别名，因此开发环境也照搬后端服务的配置 */ historyApiFallback: { rewrites: [{ from: \u0026#39;/^\\/admin/\u0026#39;, to: \u0026#39;...\u0026#39; }] } } } 踩坑  webpack-dev-server@3.2.1 requires a peer of webpack^@4.0.0 but none is installed.：这两个模块版本不兼容，回退到webpack-dev-server@2成功运行。 Cannot resolve module 'fsevents' ...：将全局的webpack调用改为直接从node_modules/webpack下直接调用，解决了问题，node node_modules/webpack/bin/webpack.js --config webpack.config.js。 Cannot resolve module 'fs' ...：配置config.node.fs = 'empty'，为Webpack提供node原生模块，使其能加载到这个对象。 热重载只对.js和.css及.vue中的\u0026lt;style\u0026gt;内样式生效，对.vue文件中的html模板及js内容都不生效，会打印“模块代码已发生改变并重新编译，但热重载不生效，可能会启用全局刷新的策略”之类的信息，暂时没有解决，初步判断是低版本的vue-hot-reload-api对这些部分的处理有问题，有大神了解原理可以在评论区科普一哈=.=。  3. 从Webpack1升级到Webpack3 由于Webpack2与Webpack3几乎完全兼容，只是涉及到一些增量的功能，因此选择直接从Webpack1迁移到Webapck3，先在项目中安装Webpack3，然后根据Webpack2文档中《从Webpack1迁移》的章节，对配置项进行更改，参考的文档戳这个：https://www.html.cn/doc/webpack2/guides/migrating/\n这次升级没有遇到什么问题，根据文档配置稍作更改就跑通了。梳理一下目前为止实现的功能：\n 新的Webpack构建代码已经实现了原有的所有功能，下面列举新增的功能。 使用webpack-dev-server作为开发服务器，实现了保存时live reload的功能。 使用http-proxy-middleware插件，将请求直接代理到测试服，让开发环境脱离了本地部署的后端服务，大大降低了开发环境部署的时间成本。 新增friendly-errors-webpack-plugin，输出友好的构建日志，打印几个重要模块的开发环境地址，配置方面完全参考了vue-cli@2的默认配置。 新增postcss-loader，对css添加兼容处理，配置方面完全参考了vue-cli@2的默认配置。 使用webpack.optimize.UglifyJsPlugin压缩js代码。  尝试进行构建，输出构建时间记录：\n npm run build：约135s npm run dev：初次构建约58s，持续构建约30s  项目构建时间过长（第一次打包把自己吓了一跳\u0026hellip;），只能继续寻求构建速度上的优化\n4. 在Webpack3下进行构建速度的优化 使用webpack-jarvis监测构建性能 webpack-jarvis是一个图形化的webpack性能监测工具，它配置简便，对构建过程的时间占比、构建结果的详细记录都有具体的输出\n// 经过简单的配置就可以在本地3001端口输出构建结果记录 const Jarvis = require(\u0026#39;webpack-jarvis\u0026#39;) module.exports = { plugins: [ new Jarvis({ watchOnly: false, port: 3001 }) ] } 使用happypack 先根据网上搜到的文章，做一些简单的优化，如使用happypack，这个模块通过多进程模型，来加速代码构建，但是使用之后貌似没有太明显的结果，构建时间大概减少了几秒吧\u0026hellip;暂时还不太懂这个模块对优化什么场景的效果比较明显，之前有看到一篇讲解happypack原理的文章，但还没细看，有兴趣小伙伴可以研究一下，要是能在评论里简洁明了的给渣渣楼主解释一下就更好了TUT：http://taobaofed.org/blog/2016/12/08/happypack-source-code-analysis/\nconst HappyPack = require(\u0026#39;happypack\u0026#39;) const os = require(\u0026#39;os\u0026#39;) const happyThreadPool = HappyPack.ThreadPool({ size: os.cpus().length }) module.exports = { plugins: [ new HappyPack({ // happypack的id，在调用时需要声明，若需要编译其他类型的文件需要再声明一个happypack  id: \u0026#39;js\u0026#39;, // cacheDirectory：设置后，将尽量在babel编译时使用缓存加载器的结果，避免重新走一遍babel的高昂代价  use: [{ loader: \u0026#39;babel-loader\u0026#39;, cacheDirectory: true }], // 根据cpu的核心数判断需要拆分多少个进程池  threadPool: happyThreadPool, // 是否输出编译过程的日志  verbose: true }) ] } 做完这一步后，输出构建时间记录：\n npm run build：约130s npm run dev：初次构建约60s，持续构建约30s  devtool配置为cheap-module-eval-source-map devtool选项启用cheap-module-eval-source-map模式：vue-cli@2默认配置为这种模式，cheap代表在输出source-map时省略列信息；module表示在编译过程中启用如babel-loader这样的预编译器，使得调试时可以直接看到未经编译的源代码；eval表示启用eval模式编译，该模式直接使用eval函数执行编译后模块的字符串，减少了将字符串转化为可执行的代码文件这个步骤，加快了项目开发中重建的速度；source-map表示输出源代码的映射表，使得开发时可以直接把错误定位到源代码，提高开发效率。\n做完这一步后，效果并不明显=.=（相比原来的source-map），大概减少了几秒，输出构建时间记录：\n npm run build：约130s npm run dev：初次构建约58s，持续构建约30s  使用html-webpack-plugin-for-multihtml提升多入口项目重建速度 重建一次竟然需要30s！各种搜索找到了html-webpack-plugin的一条issue，发现html-webpack-plugin@2在构建多入口应用时速度确实有明显变慢的情况，原因是没有成功的对构建内容进行缓存，使每次重建都重新编译所有代码。作者给出的解决方案是使用这个模块的一个分支项目（是由作者本人fork原项目并针对这个问题进行修复的项目）html-webpack-plugin-for-multihtml，用法与html-webpack-plugin完全相同，使用之后重建仅需1s左右。\n做完这一步后，输出构建时间记录：\n npm run build：约130s npm run dev：初次构建约58s，持续构建约1s  使用webpack.DllPlugin提取公共模块 在输出结果中找到了不少较大的依赖包，如Vue的核心库、lodash、echarts等等，还有一些不希望被打包的静态资源，想办法避免每次都编译这些内容，提升编译速度，所以找到了这个插件。\nwebpack.DllPlugin这个插件是来源于Windows系统的.dll文件（动态链接库）的用法：首先通过DllPlugin模块构建出一个包含公共模块的包和一个映射表，再通过DllReferencePlugin模块通过映射表给每个模块关联对应的依赖，这样可以对这些公共模块进行预先打包，以后构建的时候就不需要处理这些模块，减少打包时间。\n// webpack.dll.conf.js const webpack = require(\u0026#39;webpack\u0026#39;) module.exports = { entry: { vendor: [...] }, output: { path: resolve(\u0026#39;build/development\u0026#39;), filename: \u0026#39;[name].dll.js\u0026#39;, library: \u0026#39;[name]_library\u0026#39; }, plugins: [ new webpack.optimize.UglifyJsPlugin(), new webpack.DllPlugin({ path: resolve(\u0026#39;build/development/[name]-manifest.json\u0026#39;), // 生成manifest文件输出的位置和文件名称  name: \u0026#39;[name]-library\u0026#39;, // 与output.library是一样的，对应manifest.json文件中name字段的值，防止全局变量冲突  context: __dirname }) ] } // webpack.base.conf.js const webpack = require(\u0026#39;webpack\u0026#39;) module.exports = { plugins: [ new webpack.DllReferencePlugin({ context: __dirname, manifest: require(\u0026#39;../build/development/vendor-manifest.json\u0026#39;) // 让webpack从映射表获取使用的依赖  }) ] } 打包出来之后还需要在html文件中引入公共库vendor.dll.js文件\n\u0026lt;html\u0026gt; \u0026lt;head\u0026gt;\u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;/build/development/vendor.dll.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;!-- 其他JS应该注入到dll的后面，确保能够引用到公共库的内容 --\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 做完这一步后，输出构建时间记录，发现构建效率有了明显的提高：\n npm run dll：约25s npm run build：约70s npm run dev：初次构建约55s，持续构建约1s  5. 后记 优化到这里就差不多结束，这次的优化为旧项目提供了新一代spa项目应有的一些功能，搭建了更现代的本地开发环境。由于本文篇幅有点太长，完整的配置就丢在另一篇文章里。\n6. Q\u0026amp;A Q: 为什么不直接升级到Webpack4？\nA: Webpack4只支持vue-loader@15以上版本，而这个版本已经无法解析Vue1的文件。\n","permalink":"https://geekhouse.top/posts/engineering_vue1_update/","tags":["Engineering"],"title":"Vue1.0+Webpack1+Gulp项目升级构建方案的踩坑路"},{"categories":null,"contents":"Geek House, yyds.\n","permalink":"https://geekhouse.top/about/","tags":null,"title":"About"},{"categories":null,"contents":"","permalink":"https://geekhouse.top/search/","tags":null,"title":"Search"},{"categories":null,"contents":"","permalink":"https://geekhouse.top/timeline/","tags":null,"title":"Timeline"}]